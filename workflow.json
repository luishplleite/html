{
  "name": "MÃ©dias das Equipes x2 - Dados Reais",
  "nodes": [
    {
      "parameters": {
        "url": "https://n8n.hackathon.souamigu.org.br/webhook/dadosportohacker",
        "options": {}
      },
      "id": "f0b42e0c-3d3e-4b70-9a9e-7b8c1d2e3f4g",
      "name": "HTTP Request",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Segregate data using only real data from API\nfunction segregateData(data) {\n  const result = {\n    teams: [], users: [], mentorins: [], assessment_answers: [],\n    assessment_questions: [], assessment_questions_survey: [], \n    f_submissions: [], guilds: []\n  };\n  \n  for (const item of data) {\n    if (item.code && item.name && item.status) {\n      result.teams.push(item);\n    } else if (item.full_name && item.role) {\n      result.users.push(item);\n    } else if (item.evaluator_id) {\n      result.mentorins.push(item);\n    } else if (item.question_id && 'answer' in item) {\n      result.assessment_answers.push(item);\n    } else if (item.text && item.category) {\n      result.assessment_questions.push(item);\n    } else if (item.text && item.type && item.survey_id) {\n      result.assessment_questions_survey.push(item);\n    } else if (item.name && item.invite) {\n      const guildItem = { ...item, id: item.invite };\n      result.guilds.push(guildItem);\n    }\n  }\n  \n  return result;\n}\n\nfunction processAllTeamsData(segregatedData) {\n  const teamsResults = [];\n  \n  for (const team of segregatedData.teams) {\n    const teamId = team.id;\n    const teamName = team.name;\n    \n    // Get team members from real assessment answers\n    const teamMemberIds = new Set();\n    for (const answer of segregatedData.assessment_answers) {\n      if (answer.team_id === teamId && answer.user_id) {\n        teamMemberIds.add(answer.user_id);\n      }\n    }\n    \n    if (teamMemberIds.size === 0) {\n      continue;\n    }\n    \n    // Use real question IDs for 360 evaluation (16, 17, 18, 19)\n    const questionIds360 = [\"16\", \"17\", \"18\", \"19\"];\n    \n    // Get real evaluations for team members\n    const evaluationsReceived = segregatedData.mentorins.filter(sub => \n      teamMemberIds.has(sub.target_user_id)\n    );\n    const submissionIds = new Set(evaluationsReceived.map(sub => sub.id));\n    \n    // Get real answers for team evaluations (only from API data)\n    const allAnswers = segregatedData.assessment_answers.filter(answer => \n      submissionIds.has(answer.submission_id) && \n      questionIds360.includes(answer.question_id)\n    );\n    \n    const peerScores = [];\n    const mentorScores = [];\n    \n    for (const sub of evaluationsReceived) {\n      const evaluator = segregatedData.users.find(user => user.id === sub.evaluator_id);\n      \n      if (!evaluator) continue;\n      \n      // Get real scores for this submission\n      const scores = [];\n      for (const answer of allAnswers) {\n        if (answer.submission_id === sub.id) {\n          const value = answer.answer;\n          if (value !== null && value !== undefined) {\n            const numValue = parseFloat(value);\n            if (!isNaN(numValue)) {\n              scores.push(numValue);\n            }\n          }\n        }\n      }\n      \n      // Categorize scores based on real evaluator role\n      if (evaluator.role === 'mentor') {\n        mentorScores.push(...scores);\n      } else if (teamMemberIds.has(evaluator.id) && \n                 evaluator.id !== sub.target_user_id) {\n        peerScores.push(...scores);\n      }\n    }\n    \n    // Calculate averages from real data only\n    function calcAvg(scores) {\n      return scores.length > 0 ? parseFloat((scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(2)) : null;\n    }\n    \n    const peerAverage = calcAvg(peerScores);\n    const mentorAverage = calcAvg(mentorScores);\n    const checkpointAverage = calcAvg([...peerScores, ...mentorScores]);\n    \n    // Double the REAL values as requested (x2)\n    const peerAverageDoubled = peerAverage !== null ? parseFloat((peerAverage * 2).toFixed(2)) : null;\n    const mentorAverageDoubled = mentorAverage !== null ? parseFloat((mentorAverage * 2).toFixed(2)) : null;\n    const checkpointAverageDoubled = checkpointAverage !== null ? parseFloat((checkpointAverage * 2).toFixed(2)) : null;\n    \n    const teamResult = {\n      team_id: teamId,\n      team_name: teamName,\n      resumo_medias_equipe_x2: {\n        media_avaliacao_equipe_pares: peerAverageDoubled,\n        media_avaliacao_mentores: mentorAverageDoubled,\n        media_geral_checkpoints: checkpointAverageDoubled\n      },\n      membros_processados: teamMemberIds.size,\n      avaliacoes_processadas: evaluationsReceived.length,\n      respostas_reais_encontradas: allAnswers.length\n    };\n    \n    teamsResults.push(teamResult);\n  }\n  \n  return teamsResults;\n}\n\n// Main processing - uses only real data from API\nconst inputData = $input.first().json;\nconst segregatedData = segregateData(inputData);\nconst teamsResults = processAllTeamsData(segregatedData);\n\nreturn {\n  status: 'success',\n  total_teams: teamsResults.length,\n  timestamp: new Date().toISOString(),\n  data_source: 'API_REAL_DATA_ONLY',\n  teams_data: teamsResults\n};"
      },
      "id": "a1b23c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d",
      "name": "Processar Dados Reais",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        300
      ]
    }
  ],
  "connections": {
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Processar Dados Reais",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2024-01-01T00:00:00.000Z",
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "settings": {},
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "active": false,
  "id": "1"
}
