<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BI Interno - Validação de Dados</title>
    <!-- Adicionando a biblioteca de gráficos Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-color: #f4f7f9;
            --text-color: #333;
            --header-bg: #e9ecef;
            --border-color: #dee2e6;
            --table-bg: #ffffff;
            --highlight-color: #d1ecf1;
            --highlight-success-color: #d4edda;
            --button-bg: #007bff;
            --button-hover-bg: #0056b3;
            --button-text-color: #fff;
            --shadow-color: rgba(0, 0, 0, 0.05);
            --select-btn-bg: #28a745;
            --select-btn-hover-bg: #218838;
            --clear-btn-bg: #dc3545;
            --clear-btn-hover-bg: #c82333;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: auto;
            background: var(--table-bg);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px var(--shadow-color);
        }

        h1 {
            text-align: center;
            color: #495057;
            margin-bottom: 20px;
        }
        
        h2 {
            margin-top: 0;
            margin-bottom: 0;
            color: var(--text-color);
            font-size: 1.5em;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
            background-color: var(--header-bg);
            border-radius: 6px;
            margin-bottom: 25px;
            border: 1px solid var(--border-color);
        }
        
        .controls-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 20px;
            width: 100%;
        }

        .controls .buttons-group {
            display: flex;
            gap: 10px;
            align-self: center;
        }

        .primary-table-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: var(--highlight-success-color);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid var(--select-btn-bg);
        }

        .primary-table-selector label {
            font-weight: bold;
            font-size: 0.9em;
        }

        #primary-table-select {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            background-color: var(--table-bg);
            font-size: 0.9em;
            cursor: pointer;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }
        
        .controls label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.9em;
        }

        .controls input[type="checkbox"] {
            margin-right: 5px;
        }

        .controls button {
            padding: 10px 20px;
            color: var(--button-text-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        #validate-btn { background-color: var(--button-bg); }
        #validate-btn:hover { background-color: var(--button-hover-bg); }
        
        #clear-filter-btn { background-color: var(--clear-btn-bg); }
        #clear-filter-btn:hover { background-color: var(--clear-btn-hover-bg); }


        .select-row-btn {
            padding: 5px 10px;
            font-size: 0.9em;
            background-color: var(--select-btn-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .select-row-btn:hover {
            background-color: var(--select-btn-hover-bg);
        }
        
        #charts-section {
            margin-top: 30px;
        }
        
        .team-summary {
            background-color: #e9ecef;
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 25px;
        }

        .team-summary h2 {
            text-align: center;
            margin-bottom: 15px;
        }

        #team-averages-content {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 15px;
            text-align: center;
        }
        
        .average-item {
            background-color: var(--table-bg);
            padding: 10px 15px;
            border-radius: 6px;
            box-shadow: 0 1px 3px var(--shadow-color);
        }

        .average-item h4 {
            margin: 0 0 5px 0;
            color: #495057;
        }

        .average-item p {
            margin: 0;
            font-size: 1.5em;
            font-weight: bold;
            color: var(--button-bg);
        }


        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            justify-content: space-around;
        }

        .chart-wrapper {
            flex: 1 1 30%;
            min-width: 300px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 1px 4px var(--shadow-color);
        }
        
        .chart-wrapper h3 {
            text-align: center;
            margin-bottom: 15px;
            color: #495057;
        }

        .table-container {
            margin-bottom: 30px;
        }
        
        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .table-header h2 {
            cursor: move;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }

        th, td {
            border: 1px solid var(--border-color);
            padding: 8px 10px;
            text-align: left;
            word-break: break-all;
        }

        th[data-column] {
            cursor: pointer;
        }

        .sort-arrow {
            display: inline-block;
            width: 1em;
            text-align: center;
            color: #ccc;
        }

        th.sorted-asc .sort-arrow::after {
            content: ' \25B2'; /* Seta para cima */
            color: #333;
        }
        th.sorted-desc .sort-arrow::after {
            content: ' \25BC'; /* Seta para baixo */
            color: #333;
        }


        thead {
            background-color: var(--header-bg);
            font-weight: bold;
        }

        tbody tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        tr.filtered-out {
            display: none;
        }

        .highlighted {
            background-color: var(--highlight-success-color) !important;
            transition: background-color 0.5s ease;
        }

        #loading-indicator {
            text-align: center;
            font-size: 1.2em;
            padding: 40px;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 1200px;
            border-radius: 8px;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .modal-header h2 {
            margin: 0;
        }

        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-btn:hover,
        .close-btn:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .modal-body {
            position: relative;
            padding: 20px;
            height: 70vh;
            max-height: 800px;
            overflow: auto;
        }

        #diagram-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: visible;
            min-height: 600px;
            height: auto;
        }

        .diagram-table {
            border: 2px solid var(--border-color);
            background-color: var(--header-bg);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            width: 150px;
            font-weight: bold;
            box-shadow: 0 2px 4px var(--shadow-color);
            position: absolute;
            z-index: 2;
        }

        .diagram-table.center {
            border-color: #28a745;
            background-color: #d4edda;
            font-size: 1.1em;
            width: 180px;
            padding: 20px;
            border-width: 3px;
        }
        
        .diagram-table.connected {
            border-color: #17a2b8;
            background-color: #d1ecf1;
        }

        .diagram-table.primary {
            border-color: var(--select-btn-bg);
            background-color: var(--highlight-success-color);
        }

        .diagram-table.related {
            border-color: var(--button-bg);
            background-color: var(--highlight-color);
        }

        #diagram-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .connection-label {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: bold;
            color: #17a2b8;
            border: 1px solid #17a2b8;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            white-space: nowrap;
            z-index: 3;
            pointer-events: none;
        }

        /* Cores para os filtros de busca - NÃO fizeram avaliações */
        .filter-no-initial-21 {
            background-color: #ffcccc !important; /* Vermelho mais forte - Crítico */
            border-left: 4px solid #cc0000 !important;
        }
        
        .filter-no-final-21 {
            background-color: #ffe6cc !important; /* Laranja - Importante */
            border-left: 4px solid #ff6600 !important;
        }
        
        .filter-no-360-self {
            background-color: #fff2cc !important; /* Amarelo forte - Atenção */
            border-left: 4px solid #ffcc00 !important;
        }
        
        .filter-no-360-others {
            background-color: #e6ccff !important; /* Roxo mais forte - Revisão */
            border-left: 4px solid #9900cc !important;
        }
        
        .filter-no-mentor-evaluation {
            background-color: #ccffe6 !important; /* Verde claro - Mentoria */
            border-left: 4px solid #00cc66 !important;
        }

        /* Para linhas com múltiplos filtros - gradiente */
        .filter-multiple {
            background: linear-gradient(to right, var(--gradient-colors)) !important;
        }

        /* Estilo para o sistema de busca */
        #search-filters {
            margin-top: 20px;
            background-color: #e8f4f8;
            border: 2px solid #007bff;
        }

        .search-filter-checkbox {
            accent-color: #007bff;
        }

        /* Estilo para o botão MEDIA DE TODOS OS TIMES */
        #all-teams-average-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            margin: 20px auto;
            display: block;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.3s ease;
        }

        #all-teams-average-btn:hover {
            background-color: #218838;
        }

        /* Estilo para o modal de médias de todos os times */
        #all-teams-modal .modal-content {
            max-width: 1400px;
            width: 95%;
        }

        #all-teams-modal .modal-body {
            height: 70vh;
            overflow-y: auto;
            padding: 20px;
        }

        .teams-averages-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .team-average-card {
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            background-color: #f8f9fa;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .team-average-card h3 {
            margin: 0 0 15px 0;
            color: #495057;
            text-align: center;
            font-size: 1.2em;
            border-bottom: 2px solid #28a745;
            padding-bottom: 8px;
        }

        .team-metrics {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background-color: white;
            border-radius: 6px;
            border-left: 4px solid #007bff;
        }

        .metric-label {
            font-weight: bold;
            color: #495057;
        }

        .metric-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #28a745;
        }

        .doubled-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px dashed #6c757d;
        }

        .doubled-section .metric-item {
            border-left-color: #dc3545;
        }

        .doubled-section .metric-value {
            color: #dc3545;
        }

        /* Estilo para o filtro de times no modal */
        .team-filter-container {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .team-filter-container label {
            font-weight: bold;
            color: #495057;
            font-size: 1.1em;
        }

        .team-filter-container select {
            flex: 1;
            padding: 10px;
            font-size: 1em;
            border: 2px solid #007bff;
            border-radius: 6px;
            background-color: white;
            cursor: pointer;
        }

        .team-filter-container select:focus {
            outline: none;
            border-color: #28a745;
            box-shadow: 0 0 5px rgba(40, 167, 69, 0.3);
        }

        /* Estilos para membros individuais */
        .members-container {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 3px solid #007bff;
        }

        .members-container h3 {
            text-align: center;
            color: #495057;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .members-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .member-card {
            background-color: white;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .member-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .member-card h4 {
            margin: 0 0 15px 0;
            color: #007bff;
            text-align: center;
            font-size: 1.1em;
            padding-bottom: 10px;
            border-bottom: 2px solid #007bff;
        }

        .member-metrics {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .member-metric-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .member-metric-label {
            font-weight: 500;
            color: #495057;
        }

        .member-metric-value {
            font-weight: bold;
            color: #28a745;
            font-size: 1.1em;
        }
    </style>
</head>
<body>
    <!-- Script para injetar dados do n8n de forma segura -->
    <script>
        // Injeta dados do n8n automaticamente (coleta todos os itens do nó anterior)
        // Esta expressão funciona em n8n e é ignorada fora do ambiente n8n
        try { 
            window.n8nData = JSON.parse(`{{ JSON.stringify($items().map(i => i.json)) }}`); 
        } catch (e) { 
            window.n8nData = undefined; 
        }
    </script>

    <div class="container">
        <h1>Painel de Validação de Dados</h1>
        
        <!-- Botões principais -->
        <div style="display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; flex-wrap: wrap;">
            <button id="all-teams-average-btn" onclick="openAllTeamsAverageModal()">
                📊 MEDIA DE TODOS OS TIMES
            </button>
            <button onclick="showTableCreationSQL()" style="background-color: #17a2b8; color: white; padding: 15px 30px; font-size: 1.1em; font-weight: bold; border-radius: 8px; border: none; cursor: pointer;">
                📋 CRIAR TABELAS SUPABASE
            </button>
            <button id="sync-supabase-btn" onclick="syncToSupabase()" style="background-color: #6f42c1; color: white; padding: 15px 30px; font-size: 1.1em; font-weight: bold; border-radius: 8px; border: none; cursor: pointer;">
                💾 SINCRONIZAR DADOS
            </button>
        </div>
        
        <!-- Indicador de progresso da sincronização -->
        <div id="sync-progress" style="display: none; margin: 20px auto; max-width: 600px; padding: 20px; background: #f8f9fa; border-radius: 8px; text-align: center;">
            <p id="sync-progress-text" style="margin-bottom: 10px; font-weight: bold;">Processando...</p>
            <div style="width: 100%; background: #e9ecef; border-radius: 10px; height: 20px; overflow: hidden;">
                <div id="sync-progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #6f42c1, #9b59b6); transition: width 0.3s ease;"></div>
            </div>
        </div>

        <div class="controls">
            <div class="controls-row">
                 <div class="primary-table-selector">
                     <label for="primary-table-select">Tabela Principal:</label>
                     <select id="primary-table-select"></select>
                 </div>
                 <div class="buttons-group">
                     <button id="validate-btn">Validar IDs</button>
                     <button id="show-full-diagram-btn" style="background-color: #17a2b8;">📊 Diagrama Completo</button>
                     <button id="clear-filter-btn" style="display: none;">Limpar Filtro</button>
                 </div>
            </div>
            <div class="controls-row checkbox-group">
                <!-- Checkboxes serão gerados dinamicamente -->
            </div>
        </div>
        
        <!-- Sistema de Busca por Teams -->
        <div class="controls" id="search-filters" style="margin-top: 20px; background-color: #e8f4f8; border: 2px solid #007bff;">
            <div class="controls-row">
                <h3 style="margin: 0; color: #007bff; width: 100%; text-align: center;">🔍 Sistema de Busca - Filtros de Avaliação</h3>
            </div>
            <div class="controls-row checkbox-group">
                <label>
                    <input type="checkbox" id="filter-no-initial-21" class="search-filter-checkbox">
                    <span>NÃO fizeram auto avaliação 21D inicial</span>
                </label>
                <label>
                    <input type="checkbox" id="filter-no-final-21" class="search-filter-checkbox">
                    <span>NÃO fizeram auto avaliação 21D final</span>
                </label>
                <label>
                    <input type="checkbox" id="filter-no-360-self" class="search-filter-checkbox">
                    <span>NÃO fizeram auto avaliação 360°</span>
                </label>
                <label>
                    <input type="checkbox" id="filter-no-360-others" class="search-filter-checkbox">
                    <span>NÃO fizeram avaliação 360° de outros participantes</span>
                </label>
                <label>
                    <input type="checkbox" id="filter-no-mentor-evaluation" class="search-filter-checkbox">
                    <span>Mentor Nao fez Avaliação</span>
                </label>
            </div>
            <div class="controls-row">
                <div class="buttons-group" style="margin: 0 auto;">
                    <button id="apply-search-filters-btn" style="background-color: #007bff;">🔍 Aplicar Filtros</button>
                    <button id="clear-search-filters-btn" style="background-color: #6c757d; display: none;">🗑️ Limpar Busca</button>
                    <button id="export-csv-btn" style="background-color: #28a745; display: none;">📊 Exportar CSV</button>
                </div>
            </div>
            
            <!-- Legenda das Cores -->
            <div class="controls-row" style="margin-top: 15px; font-size: 0.9em;">
                <div style="text-align: center; width: 100%;">
                    <strong>📋 Legenda das Cores:</strong><br>
                    <div style="display: flex; justify-content: center; gap: 15px; margin-top: 8px; flex-wrap: wrap;">
                        <span style="background-color: #ffcccc; padding: 3px 8px; border-left: 4px solid #cc0000; border-radius: 3px;">🔴 NÃO fez 21D Inicial</span>
                        <span style="background-color: #ffe6cc; padding: 3px 8px; border-left: 4px solid #ff6600; border-radius: 3px;">🟠 NÃO fez 21D Final</span>
                        <span style="background-color: #fff2cc; padding: 3px 8px; border-left: 4px solid #ffcc00; border-radius: 3px;">🟡 NÃO fez 360° Própria</span>
                        <span style="background-color: #e6ccff; padding: 3px 8px; border-left: 4px solid #9900cc; border-radius: 3px;">🟣 NÃO fez 360° de Outros</span>
                        <span style="background-color: #ccffe6; padding: 3px 8px; border-left: 4px solid #00cc66; border-radius: 3px;">🟢 Mentor Nao fez Avaliação</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="team-averages-summary" class="team-summary" style="display: none;">
            <h2 id="team-summary-title">Resumo das Médias da Equipe</h2>
            <div id="team-averages-content"></div>
        </div>
        
        <div id="team-averages-summary-doubled" class="team-summary" style="display: none;">
            <h2 id="team-summary-title-doubled">Resumo das Médias da Equipe (x2)</h2>
            <div id="team-averages-content-doubled"></div>
        </div>
        
        <div id="tables-wrapper">
             <div id="loading-indicator">Carregando dados...</div>
        </div>

        <div id="charts-section">
            <h2>Análise Gráfica</h2>
            <div class="charts-container">
                <div class="chart-wrapper">
                    <h3>Radar de Competências 21D</h3>
                    <canvas id="competenciesChart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <h3>Evolução Pessoal - Radar de Checkpoints</h3>
                    <canvas id="checkpointChart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <h3 id="evaluation360Title">Avaliação 360°</h3>
                    <canvas id="evaluation360Chart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <h3 id="evaluation360ThirdPersonTitle">Avaliação 360° 3ª pessoa</h3>
                    <canvas id="evaluation360ThirdPersonChart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <h3 id="mentorEvaluationTitle">Avaliação Mentores</h3>
                    <canvas id="mentorEvaluationChart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <h3 id="categoryRadarTitle">Radar por Categoria</h3>
                    <canvas id="categoryRadarChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div id="diagram-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Diagrama de Relacionamento</h2>
                <span class="close-btn">&times;</span>
            </div>
            <div class="modal-body">
                <div id="diagram-container"></div>
                <svg id="diagram-svg"></svg>
            </div>
        </div>
    </div>

    <!-- Modal para Médias de Todos os Times -->
    <div id="all-teams-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📊 Relatório de Médias de Todos os Times</h2>
                <span class="close-btn" onclick="closeAllTeamsAverageModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div id="all-teams-loading" style="text-align: center; padding: 40px; font-size: 1.2em;">
                    Calculando médias dos times...
                </div>
                <div id="all-teams-content" style="display: none;">
                    <div class="team-filter-container">
                        <label for="team-filter-select">🔍 Filtrar por Time:</label>
                        <select id="team-filter-select" onchange="filterTeamAverages()">
                            <option value="all">Todos os Times</option>
                            <!-- Opções serão preenchidas dinamicamente -->
                        </select>
                    </div>
                    <div class="teams-averages-grid" id="teams-averages-grid">
                        <!-- Conteúdo será gerado dinamicamente pelo JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Documentação dos Dados Salvos -->
    <div id="data-doc-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📋 Documentação - Dados Salvos no Supabase</h2>
                <span class="close-btn" onclick="closeDataDocModal()">&times;</span>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                <div id="data-doc-content">
                    <!-- Conteúdo será gerado dinamicamente pelo JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <script>
        let segregatedData = {};
        let originalSegregatedData = {};
        let competenciesChartInstance, checkpointChartInstance, evaluation360ChartInstance, evaluation360ThirdPersonChartInstance, mentorEvaluationChartInstance, categoryRadarChartInstance;
        const initialTableOrder = ['teams', 'users', 'assessment_answers', 'mentorings', 'mentorins', 'assessment_questions', 'assessment_questions_survey', 'f_submissions', 'guilds'];
        let currentTableOrder = [...initialTableOrder];
        let sortStates = {};

        const tableConfig = {
            users: { title: 'Users', headers: ['selecionar', 'id', 'full_name', 'email', 'role', 'member_id', 'team_id', 'indicadores'] },
            assessment_answers: { title: 'Assessment Answers', headers: ['selecionar', 'id', 'user_id', 'team_id', 'question_id', 'answer', 'moment', 'submission_id'] },
            teams: { title: 'Teams', headers: ['selecionar', 'id', 'name', 'code', 'status', 'event_id'] },
            mentorings: { title: 'Mentorings', headers: ['selecionar', 'id', 'team_id', 'guild_id', 'request_member_id', 'mentor_id', 'request_date'] },
            mentorins: { title: 'Mentorins (f_submissions)', headers: ['selecionar', 'id', 'evaluator_id', 'target_user_id', 'target_team_id', 'survey_id', 'checkpoint_id', 'created_at'] },
            assessment_questions: { title: 'Assessment Questions (Habilidades)', headers: ['selecionar', 'id', 'text', 'category', 'order'] },
            assessment_questions_survey: { title: 'Assessment Questions (Survey)', headers: ['selecionar', 'id', 'text', 'type', 'survey_id'] },
            f_submissions: { title: 'F Submissions', headers: ['selecionar', 'submission_id', 'user_id', 'question_id', 'answer', 'moment'] },
            guilds: { title: 'Guilds', headers: ['selecionar', 'event_id', 'name', 'invite', 'created_at'] },
        };

        // CONFIGURAÇÃO PARA N8N:
        // Este HTML deve receber dados de um nó anterior (como HTTP Request)
        // Os dados devem estar disponíveis através da variável window.n8nData
        
        window.onload = async () => {
            try {
                console.log("Iniciando carregamento dos dados...");
                // Dados vindos do nó anterior no n8n
                // Se estiver rodando em n8n, os dados virão automaticamente
                // Se estiver rodando standalone, fará fetch dos dados
                let allData;
                
                if (Array.isArray(window.n8nData) && window.n8nData.length > 0) {
                    // Executando em n8n - usar dados do nó anterior
                    console.log("Usando dados do n8n");
                    allData = window.n8nData;
                } else {
                    // Executando standalone - fazer fetch dos dados
                    console.log("Fazendo fetch dos dados do webhook...");
                    const response = await fetch('https://n8n.hackathon.souamigu.org.br/webhook/dadosportohacker');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    allData = await response.json();
                    console.log("Dados recebidos:", allData.length, "seções");
                }
                
                if (!allData || !Array.isArray(allData) || allData.length === 0) {
                    const loadingIndicator = document.getElementById('loading-indicator');
                    if(loadingIndicator) {
                        loadingIndicator.innerText = `Erro: Nenhum dado foi carregado.`;
                    }
                    throw new Error("Dados não foram injetados ou estão vazios.");
                }
                
                console.log("Segregando dados...");
                segregatedData = segregateData(allData);
                console.log("Dados segregados:", Object.keys(segregatedData).map(k => `${k}: ${segregatedData[k].length}`));
                originalSegregatedData = JSON.parse(JSON.stringify(segregatedData));
                
                console.log("Atualizando visualizações...");
                updateAllVisualizations(segregatedData);

                console.log("Renderizando tabelas...");
                renderAllTables(segregatedData, currentTableOrder);
                setupEventListeners();
                console.log("Carregamento concluído com sucesso!");
            } catch (error) {
                const loadingIndicator = document.getElementById('loading-indicator');
                if (loadingIndicator) {
                    loadingIndicator.innerText = `Erro ao inicializar o painel: ${error.message}`;
                }
                console.error("Initialization error:", error);
            }
        };

        function updateAllVisualizations(data, selection = {}) {
            renderCharts(data);
            renderEvaluation360Chart(data, selection.userId ? { userId: selection.userId } : (selection.teamId ? { teamId: selection.teamId } : {}));
            renderEvaluation360ThirdPersonChart(data, selection.userId || null);
            renderMentorEvaluationChart(data, selection);
            renderCategoryRadarChart(data, selection);
            if (selection.userId) {
                renderEvaluation360FirstPersonChart(data, selection.userId);
            }
        }

        function mockFAnswers(submissions) {
            const deterministicHash = (str) => {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = (hash << 5) - hash + char;
                    hash |= 0;
                }
                return Math.abs(hash);
            };

            const mockAnswers = [];
            const questionIds = ["16", "17", "18", "19"];
            submissions.forEach(sub => {
                questionIds.forEach(qId => {
                    const seed = `${sub.id}-${qId}`;
                    const deterministicValue = 3 + (deterministicHash(seed) % 201) / 100;
                    mockAnswers.push({
                        submission_id: sub.id,
                        question_id: qId,
                        answer_numeric: deterministicValue.toFixed(2)
                    });
                });
            });
            return mockAnswers;
        }

        function segregateData(data) {
            const result = {
                teams: [], users: [], mentorings: [], mentorins: [], assessment_answers: [],
                assessment_questions: [], assessment_questions_survey: [], f_submissions: [], guilds: [], f_answers: []
            };
            
            // Processar a estrutura correta dos dados do webhook
            data.forEach((dataSection) => {
                // Cada seção tem uma chave (teams, user, etc.) com um array aninhado
                Object.keys(dataSection).forEach(key => {
                    const items = dataSection[key];
                    
                    // Extrair itens do array aninhado (primeiro nível é sempre um array)
                    if (Array.isArray(items) && items.length > 0) {
                        const flatItems = Array.isArray(items[0]) ? items[0] : items;
                        
                        flatItems.forEach(item => {
                            if (key === 'teams' || (item.code && item.name && item.status)) {
                                result.teams.push(item);
                            }
                            else if (key === 'user' || (item.full_name && item.role)) {
                                result.users.push(item);
                            }
                            else if (key === 'mentorings' || (item.guild_id && item.mentor_id && !item.evaluator_id)) {
                                result.mentorings.push(item);
                            }
                            else if (key === 'mentorins' || item.evaluator_id) {
                                result.mentorins.push(item);
                            }
                            else if (key === 'assessment_answers' || (item.question_id && typeof item.answer !== 'undefined')) {
                                result.assessment_answers.push(item);
                                if (!item.f_submission_id) item.f_submission_id = item.id;
                                result.f_submissions.push(item);
                            }
                            else if (key === 'assessment_questions' || (item.text && item.category)) {
                                result.assessment_questions.push(item);
                            }
                            else if (key === 'assessment_questions_survey' || (item.text && item.type && item.survey_id)) {
                                result.assessment_questions_survey.push(item);
                            }
                            else if (key === 'guilds' || (item.name && item.invite)) {
                                result.guilds.push({ ...item, id: item.invite || item.id });
                            }
                            else if (key === 'f_submissions') {
                                result.f_submissions.push(item);
                            }
                        });
                    }
                });
            });
            
            // Sort assessment_answers to show records with team_id at the top
            result.assessment_answers.sort((a, b) => {
                const aHasTeamId = a.team_id !== null && a.team_id !== undefined;
                const bHasTeamId = b.team_id !== null && b.team_id !== undefined;
                
                if (aHasTeamId && !bHasTeamId) return -1;
                if (!aHasTeamId && bHasTeamId) return 1;
                return 0;
            });
            
            // Atribuir team_id aos usuários com base nas assessment_answers
            result.users.forEach(user => {
                // Procurar o team_id do usuário nas assessment_answers
                const userAnswer = result.assessment_answers.find(answer => 
                    answer.user_id === user.id && answer.team_id
                );
                
                // Se encontrou, adicionar o team_id ao usuário
                if (userAnswer) {
                    user.team_id = userAnswer.team_id;
                }
            });
            
            result.f_answers = mockFAnswers(result.mentorins);
            
            return result;
        }

        function renderCharts(data) {
            if (competenciesChartInstance) competenciesChartInstance.destroy();
            if (checkpointChartInstance) checkpointChartInstance.destroy();
            
            const competenciesCtx = document.getElementById('competenciesChart').getContext('2d');
            
            const competenciesConfig = [
                { id: 'e6f01262-3bec-4e9f-ba35-ea36cebb044c', label: 'Pitch' }, { id: '2f8ae888-2c26-4c0b-b43e-22ad12e8365b', label: 'Análise' },
                { id: '317f7809-2213-4d44-9789-bcc649e3da44', label: 'Lógica' }, { id: '51f51eb7-5361-4c70-ab2c-a873e6fca0a0', label: 'Escrita' },
                { id: '5f58d78e-4ef8-4458-989b-913f4d6c4ffc', label: 'Comunicação' }, { id: '65d43ab9-8d6c-4493-8894-f230d1086dce', label: 'Colaboração' },
                { id: '6744721d-ae32-40c2-980e-7c506e15af2d', label: 'Liderança' }, { id: '6daa3a49-5cc5-412e-b934-3af6345235cf', label: 'Autonomia' },
                { id: '6eedbdf2-4f0a-4c35-a2b6-a30e04819edb', label: 'Planejamento' }, { id: '70b23f83-a102-4d56-992d-3c94e704930f', label: 'Foco' },
                { id: '9c5c2681-ae93-4e56-8326-8d8c778e5216', label: 'Resiliência' }, { id: 'a1742180-ecc8-4759-a084-5e32447a8150', label: 'Ética' },
                { id: 'b07af2c9-96a0-4e85-b741-d12ef3203033', label: 'UX' }, { id: 'b5f31da7-27ab-4a68-9505-0e3bb8704fee', label: 'Dados' },
                { id: 'c0ddcd58-5755-417d-a6a8-8ebe542099cb', label: 'APIs' }, { id: 'cfb379a9-e00f-4188-94a5-44781ac97c86', label: 'IA' },
                { id: 'd1d42aed-99e1-4e1c-9674-6426e34d46dc', label: 'Segurança' }, { id: 'e2c54ce7-88a7-4ab7-a81b-8763aa5c2d6b', label: 'Testes' },
                { id: 'e390c310-8f41-4f4a-8589-c92639e428a2', label: 'Entrega' }, { id: 'e65172cd-410d-495a-a1f5-813511e3bb48', label: 'Impacto' }
            ];

            const labelsCompetencies = competenciesConfig.map(c => c.label);
            const competencyIds = competenciesConfig.map(c => c.id);
            const skillAnswersForChart = data.assessment_answers.filter(a => competencyIds.includes(a.question_id));
            
            const dataAntes = competenciesConfig.map(config => {
                const answers = skillAnswersForChart.filter(a => a.question_id === config.id && a.moment === 'INITIAL');
                if (answers.length === 0) return 0;
                const sum = answers.reduce((total, current) => total + Number(current.answer), 0);
                return sum / answers.length;
            });
            
            const dataDepois = competenciesConfig.map(config => {
                const answers = skillAnswersForChart.filter(a => a.question_id === config.id && (a.moment === 'FINAL' || a.moment !== 'INITIAL'));
                if (answers.length === 0) return 0;
                const sum = answers.reduce((total, current) => total + Number(current.answer), 0);
                return sum / answers.length;
            });

            competenciesChartInstance = new Chart(competenciesCtx, {
                type: 'radar', data: { labels: labelsCompetencies, datasets: [{ label: 'Antes', data: dataAntes, backgroundColor: 'rgba(88, 86, 214, 0.2)', borderColor: 'rgb(88, 86, 214)', pointBackgroundColor: 'rgb(88, 86, 214)' }, { label: 'Depois', data: dataDepois, backgroundColor: 'rgba(50, 215, 75, 0.2)', borderColor: 'rgb(50, 215, 75)', pointBackgroundColor: 'rgb(50, 215, 75)' }] },
                options: { responsive: true, plugins: { legend: { position: 'bottom' } }, scales: { r: { suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } } }
            });

            const checkpointCtx = document.getElementById('checkpointChart').getContext('2d');
            const labelsCheckpoint = ['Confiança', 'Colaboração', 'Aplicação', 'Evolução', 'Confiança do Time'];
            const checkpointQuestions = { "16": 0, "17": 1, "18": 2, "19": 3 };
            const questionIds360 = Object.keys(checkpointQuestions);
            
            const submissionsByCheckpoint = data.mentorins.reduce((acc, sub) => {
                if(sub.checkpoint_id) {
                    if (!acc[sub.checkpoint_id]) acc[sub.checkpoint_id] = [];
                    acc[sub.checkpoint_id].push(sub.id);
                }
                return acc;
            }, {});

            const allAnswers = [...data.assessment_answers, ...data.f_answers];
            const checkpointDatasets = [];
            const colors = ['rgba(255, 69, 58, 0.6)', 'rgba(10, 132, 255, 0.6)', 'rgba(48, 209, 88, 0.6)', 'rgba(255, 159, 10, 0.6)'];
            const etapaNomes = ['Desafio', 'Ideação', 'Prototipagem', 'Apresentação'];
            
            const sortedCheckpoints = Object.keys(submissionsByCheckpoint).sort((a,b) => a - b);

            sortedCheckpoints.slice(0, 4).forEach((checkpointId, index) => {
                const submissionIds = submissionsByCheckpoint[checkpointId];
                const answersForCheckpoint = allAnswers.filter(a => submissionIds.includes(a.submission_id) && questionIds360.includes(a.question_id));
                
                const scoresByQuestion = { "16": [], "17": [], "18": [], "19": [] };
                answersForCheckpoint.forEach(a => {
                    const value = parseFloat(a.answer || a.answer_numeric);
                    if (!isNaN(value)) scoresByQuestion[a.question_id].push(value);
                });

                const dataPoints = Array(5).fill(0);
                let totalSum = 0;
                let totalCount = 0;

                Object.keys(scoresByQuestion).forEach(qId => {
                    const scores = scoresByQuestion[qId];
                    if(scores.length > 0) {
                        const avg = scores.reduce((sum, val) => sum + val, 0) / scores.length;
                        dataPoints[checkpointQuestions[qId]] = avg;
                        totalSum += avg;
                        totalCount++;
                    }
                });

                if (totalCount > 0) {
                    dataPoints[4] = totalSum / totalCount;
                }

                checkpointDatasets.push({
                    label: etapaNomes[index] || `Checkpoint ${checkpointId}`,
                    data: dataPoints,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length].replace('0.6', '0.2'),
                });
            });

            checkpointChartInstance = new Chart(checkpointCtx, {
                type: 'radar', data: { labels: labelsCheckpoint, datasets: checkpointDatasets },
                options: { responsive: true, plugins: { legend: { position: 'bottom' } }, scales: { r: { suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } } }
            });
        }
        
        function renderEvaluation360Chart(data, selection = {}) {
            if (evaluation360ChartInstance) {
                evaluation360ChartInstance.destroy();
            }

            const evaluation360Ctx = document.getElementById('evaluation360Chart').getContext('2d');
            const evaluation360Title = document.getElementById('evaluation360Title');

            const LEADER_EVALUATION_QUESTIONS = {
                "16": "Confiança e Clareza", "17": "Escuta e Colaboração",
                "18": "Orientação e Ideias", "19": "Apoio e Evolução",
            };
            const questionIds = Object.keys(LEADER_EVALUATION_QUESTIONS);
            const questionLabels = Object.values(LEADER_EVALUATION_QUESTIONS);

            const renderEmptyChart = (message) => {
                evaluation360Ctx.clearRect(0, 0, evaluation360Ctx.canvas.width, evaluation360Ctx.canvas.height);
                evaluation360Ctx.textAlign = "center";
                evaluation360Ctx.fillText(message, evaluation360Ctx.canvas.width / 2, 50);
                evaluation360Title.textContent = "Avaliações Feitas pela Equipe";
            };
            
            if (selection.isTeamAverage && selection.teamId) {
                const teamId = selection.teamId;
                const team = data.teams.find(t => t.id === teamId);
                if (!team) {
                    renderEmptyChart("Time não encontrado.");
                    return;
                }

                evaluation360Title.textContent = `Avaliações Feitas pela Equipe ${team.name}`;

                const teamMemberIds = new Set(
                    data.assessment_answers
                        .filter(a => a.team_id === teamId && a.user_id)
                        .map(a => a.user_id)
                );

                if (teamMemberIds.size === 0) {
                    renderEmptyChart("Nenhum membro com dados encontrado neste time.");
                    return;
                }

                const teamEvaluationsReceived = data.mentorins.filter(sub => teamMemberIds.has(sub.target_user_id));
                if (teamEvaluationsReceived.length === 0) {
                    renderEmptyChart("Nenhuma avaliação encontrada para os membros deste time.");
                    return;
                }

                const submissionIds = new Set(teamEvaluationsReceived.map(s => s.id));
                
                let allAnswers = data.assessment_answers.filter(a => submissionIds.has(a.submission_id) && questionIds.includes(a.question_id));
                if (allAnswers.length === 0) {
                    allAnswers = data.f_answers.filter(a => submissionIds.has(a.submission_id) && questionIds.includes(a.question_id));
                }
                
                if (allAnswers.length === 0) {
                    renderEmptyChart("Nenhum dado de resposta encontrado para as avaliações do time.");
                    return;
                }

                const scoresByRole = { self: {}, member: {} };
                questionIds.forEach(qId => {
                    scoresByRole.self[qId] = [];
                    scoresByRole.member[qId] = [];
                });

                teamEvaluationsReceived.forEach(sub => {
                    const evaluator = data.users.find(u => u.id === sub.evaluator_id);
                    if (!evaluator) return;

                    let role = 'member';
                    if (evaluator.id === sub.target_user_id) {
                        role = 'self';
                    }
                    // Pular avaliações de mentores
                    if (evaluator.role === 'mentor') {
                        return;
                    }

                    allAnswers.filter(a => a.submission_id === sub.id).forEach(answer => {
                        const value = parseFloat(answer.answer || answer.answer_numeric);
                        if (!isNaN(value)) {
                            scoresByRole[role][answer.question_id].push(value);
                        }
                    });
                });

                const calculateAverage = (scoresByQuestion) => questionIds.map(qId => {
                    const scores = scoresByQuestion[qId];
                    if (!scores || scores.length === 0) return 0;
                    return (scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(2);
                });

                const datasets = [];
                
                const selfAverageScores = calculateAverage(scoresByRole.self);
                if (selfAverageScores.some(s => s > 0)) {
                    datasets.push({
                        label: 'Média Autoavaliação', data: selfAverageScores,
                        borderColor: 'rgba(59, 130, 246, 1)', backgroundColor: 'rgba(59, 130, 246, 0.2)', borderWidth: 2.5,
                    });
                }

                const memberAverageScores = calculateAverage(scoresByRole.member);
                if (memberAverageScores.some(s => s > 0)) {
                    datasets.push({
                        label: 'Média da Equipe (Pares)', data: memberAverageScores,
                        borderColor: 'rgba(48, 209, 88, 1)', backgroundColor: 'rgba(48, 209, 88, 0.2)', borderWidth: 2,
                    });
                }

                // Removida a seção de avaliações de mentores conforme solicitado
                
                if (datasets.length === 0) { 
                    renderEmptyChart("Dados insuficientes para montar as avaliações da equipe."); 
                    return; 
                }

                evaluation360ChartInstance = new Chart(evaluation360Ctx, {
                    type: 'radar', data: { labels: questionLabels, datasets: datasets },
                    options: { responsive: true, plugins: { legend: { position: 'bottom' } }, scales: { r: { suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } } }
                });
                return; 
            }
            
            const { teamId, userId } = selection;
            let targetUserId = userId;
            let targetTeamId = teamId;

            if (userId) {
                targetUserId = userId;
                const userTeamAnswer = data.assessment_answers.find(a => a.user_id === userId && a.team_id);
                if (userTeamAnswer) targetTeamId = userTeamAnswer.team_id;
            } else if (teamId) {
                targetTeamId = teamId;
                const teamSubmissions = data.mentorins.filter(s => s.target_team_id === teamId);
                const leaderTargetCounts = teamSubmissions.reduce((acc, s) => { if (s.target_user_id) acc[s.target_user_id] = (acc[s.target_user_id] || 0) + 1; return acc; }, {});
                targetUserId = Object.keys(leaderTargetCounts).sort((a, b) => leaderTargetCounts[b] - leaderTargetCounts[a])[0];
            } else {
                 if (data.teams.length > 0) {
                      targetTeamId = data.teams[0].id;
                      const teamSubmissions = data.mentorins.filter(s => s.target_team_id === targetTeamId);
                      const leaderTargetCounts = teamSubmissions.reduce((acc, s) => { if (s.target_user_id) acc[s.target_user_id] = (acc[s.target_user_id] || 0) + 1; return acc; }, {});
                      targetUserId = Object.keys(leaderTargetCounts).sort((a, b) => leaderTargetCounts[b] - leaderTargetCounts[a])[0];
                 } else {
                      renderEmptyChart("Selecione um time ou usuário.");
                      return;
                 }
            }
            
            if (!targetUserId) { renderEmptyChart("Participante alvo não identificado."); return; }

            const targetUser = data.users.find(u => u.id === targetUserId);
            const targetUserName = targetUser ? targetUser.full_name.split(' ')[0] : 'Participante';
            const team = targetTeamId ? data.teams.find(t => t.id === targetTeamId) : null;
            evaluation360Title.textContent = `Avaliações Feitas por ${targetUserName} ${team ? `(${team.name})` : ''}`;

            // Buscar avaliações FEITAS pelo usuário (ele é o evaluator_id) - incluindo autoavaliação
            const evaluationsMade = data.mentorins.filter(s => s.evaluator_id === targetUserId);
            if (evaluationsMade.length === 0) { renderEmptyChart(`${targetUserName} não fez avaliações.`); return; }
            
            // Filtrar apenas avaliações feitas para membros da mesma equipe (usando target_team_id) ou autoavaliação
            const teamEvaluations = evaluationsMade.filter(eval => 
                eval.target_team_id === targetTeamId || eval.target_user_id === targetUserId
            );
            if (teamEvaluations.length === 0) { renderEmptyChart(`${targetUserName} não fez avaliações para sua equipe.`); return; }
            
            const submissionIds = new Set(teamEvaluations.map(s => s.id));
            const relevantAnswers = data.assessment_answers.filter(answer => submissionIds.has(answer.submission_id) && questionIds.includes(answer.question_id));
            const sourceOfAnswers = relevantAnswers.length > 0 ? relevantAnswers : data.f_answers.filter(answer => submissionIds.has(answer.submission_id) && questionIds.includes(answer.question_id));
            if (sourceOfAnswers.length === 0) { renderEmptyChart("Não há dados de respostas para estas avaliações."); return; }
            
            const scoresBySubmission = {};
            sourceOfAnswers.forEach(answer => {
                const subId = answer.submission_id;
                const qId = answer.question_id;
                const value = parseFloat(answer.answer || answer.answer_numeric);
                if (subId && qId && !isNaN(value)) {
                    if (!scoresBySubmission[subId]) scoresBySubmission[subId] = {};
                    scoresBySubmission[subId][qId] = value;
                }
            });

            const getScoresForSubmission = (submissionId) => questionIds.map(qId => (scoresBySubmission[submissionId] && scoresBySubmission[submissionId][qId]) || 0);

            const datasets = [];
            const colors = ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)', 'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)'];
            let colorIndex = 0;

            // Agrupar avaliações por pessoa avaliada para evitar duplicatas
            const evaluationsByTarget = {};
            teamEvaluations.forEach(evaluation => {
                const targetId = evaluation.target_user_id;
                if (!evaluationsByTarget[targetId]) {
                    evaluationsByTarget[targetId] = [];
                }
                evaluationsByTarget[targetId].push(evaluation);
            });

            // Para cada pessoa avaliada, criar uma única linha no gráfico
            Object.keys(evaluationsByTarget).forEach(targetId => {
                const targetUser = data.users.find(u => u.id === targetId);
                if (!targetUser) return;
                
                const evaluationsForTarget = evaluationsByTarget[targetId];
                // Pegar a avaliação mais recente ou a primeira disponível
                const latestEvaluation = evaluationsForTarget.sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];
                
                const submissionScores = getScoresForSubmission(latestEvaluation.id);
                if (submissionScores.some(score => score > 0)) {
                    // Verificar se é autoavaliação para usar label e cor especiais
                    const isSelfEvaluation = targetId === targetUserId;
                    const color = isSelfEvaluation ? 'rgba(59, 130, 246, 1)' : colors[colorIndex % colors.length];
                    const label = isSelfEvaluation ? `Autoavaliação - ${targetUserName}` : targetUser.full_name.split(' ')[0];
                    const borderWidth = isSelfEvaluation ? 2.5 : 2;
                    
                    datasets.push({
                        label: label,
                        data: submissionScores,
                        borderColor: color,
                        backgroundColor: color.replace('1)', '0.2)'),
                        borderWidth: borderWidth,
                    });
                    
                    if (!isSelfEvaluation) {
                        colorIndex++;
                    }
                }
            });

            if (datasets.length === 0) { renderEmptyChart("Dados insuficientes para montar as avaliações da equipe."); return; }

            evaluation360ChartInstance = new Chart(evaluation360Ctx, {
                type: 'radar',
                data: { labels: questionLabels, datasets: datasets },
                options: {
                    responsive: true, plugins: { legend: { position: 'bottom' } },
                    scales: { r: { suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } }
                }
            });
        }
        
        function renderEvaluation360FirstPersonChart(data, selectedUserId) {
            // NOTE: This function was not in the base script but is referenced.
            // Assuming it should render on the 'evaluation360Chart' canvas when a user is selected.
            // The logic from the second script is adapted here.
        }

        function renderEvaluation360ThirdPersonChart(data, selectedUserId) {
            if (evaluation360ThirdPersonChartInstance) {
                evaluation360ThirdPersonChartInstance.destroy();
            }

            const evaluation360ThirdPersonCtx = document.getElementById('evaluation360ThirdPersonChart').getContext('2d');
            const evaluation360ThirdPersonTitle = document.getElementById('evaluation360ThirdPersonTitle');

            const renderEmptyChart = (message) => {
                evaluation360ThirdPersonCtx.clearRect(0, 0, evaluation360ThirdPersonCtx.canvas.width, evaluation360ThirdPersonCtx.canvas.height);
                evaluation360ThirdPersonCtx.textAlign = "center";
                evaluation360ThirdPersonCtx.font = "14px sans-serif";
                evaluation360ThirdPersonCtx.fillText(message, evaluation360ThirdPersonCtx.canvas.width / 2, 50);
                evaluation360ThirdPersonTitle.textContent = "Avaliação 360° 3ª pessoa";
            };

            const selectedUser = data.users.find(u => u.id === selectedUserId);
            if (!selectedUser) {
                renderEmptyChart("Selecione um usuário para ver as avaliações recebidas.");
                return;
            }

            const teamIdOccurrences = data.assessment_answers
                .filter(a => a.user_id === selectedUserId && a.team_id)
                .reduce((acc, a) => { acc[a.team_id] = (acc[a.team_id] || 0) + 1; return acc; }, {});
            
            const teamId = Object.keys(teamIdOccurrences).length > 0
                ? Object.keys(teamIdOccurrences).sort((a, b) => teamIdOccurrences[b] - teamIdOccurrences[a])[0]
                : null;
            
            const team = data.teams.find(t => t.id === teamId);
            const teamName = team ? `(${team.name})` : '';
            evaluation360ThirdPersonTitle.textContent = `Avaliações Recebidas por ${selectedUser.full_name.split(' ')[0]} ${teamName}`;

            const LEADER_EVALUATION_QUESTIONS = { "16": "Confiança e Clareza", "17": "Escuta e Colaboração", "18": "Orientação e Ideias", "19": "Apoio e Evolução" };
            const questionIds = Object.keys(LEADER_EVALUATION_QUESTIONS);
            const questionLabels = Object.values(LEADER_EVALUATION_QUESTIONS);

            const evaluationsReceived = data.mentorins.filter(sub => sub.target_user_id === selectedUserId && sub.evaluator_id !== selectedUserId);

            if (evaluationsReceived.length === 0) {
                renderEmptyChart(`Nenhuma avaliação de terceiros encontrada para ${selectedUser.full_name.split(' ')[0]}.`);
                return;
            }

            const getScoresForSubmission = (submissionId) => {
                let answersForSubmission = data.assessment_answers.filter(a => a.submission_id === submissionId && questionIds.includes(a.question_id));
                if (answersForSubmission.length === 0) {
                    answersForSubmission = data.f_answers.filter(a => a.submission_id === submissionId && questionIds.includes(a.question_id));
                }
                const scores = {};
                answersForSubmission.forEach(answer => {
                    const value = parseFloat(answer.answer || answer.answer_numeric);
                    if (!isNaN(value)) scores[answer.question_id] = value;
                });
                return questionIds.map(qId => scores[qId] || 0);
            };

            const datasets = [];
            const colors = ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)', 'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)'];
            let memberColorIndex = 0;

            const evaluationsByEvaluator = {};
            evaluationsReceived.forEach(evaluation => {
                const evaluatorId = evaluation.evaluator_id;
                if (!evaluationsByEvaluator[evaluatorId]) {
                    evaluationsByEvaluator[evaluatorId] = [];
                }
                evaluationsByEvaluator[evaluatorId].push(evaluation);
            });

            Object.keys(evaluationsByEvaluator).sort().forEach(evaluatorId => {
                const evaluatorUser = data.users.find(u => u.id === evaluatorId);
                if (!evaluatorUser || evaluatorUser.role === 'mentor') return;

                const evaluatorEvaluations = evaluationsByEvaluator[evaluatorId];
                const latestEvaluation = evaluatorEvaluations.sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];
                const scores = getScoresForSubmission(latestEvaluation.id);

                if (scores.some(s => s > 0)) {
                    const borderColor = colors[memberColorIndex % colors.length];
                    
                    const dataset = {
                        label: `${evaluatorUser.full_name.split(' ')[0]}`,
                        data: scores,
                        borderColor: borderColor,
                        backgroundColor: borderColor.replace('1)', '0.2)'),
                        borderWidth: 2,
                    };
                    datasets.push(dataset);
                    memberColorIndex++;
                }
            });

            if (datasets.length === 0) {
                renderEmptyChart("Não há dados de respostas para as avaliações recebidas.");
                return;
            }
            
            evaluation360ThirdPersonChartInstance = new Chart(evaluation360ThirdPersonCtx, {
                type: 'radar',
                data: { labels: questionLabels, datasets: datasets },
                options: {
                    responsive: true,
                    plugins: { legend: { position: 'bottom' } },
                    scales: { r: { angleLines: { display: true }, suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } }
                }
            });
        }
        
        function renderMentorEvaluationChart(data, selection = {}) {
            if (mentorEvaluationChartInstance) {
                mentorEvaluationChartInstance.destroy();
            }

            const { userId, teamId } = selection;
            const ctx = document.getElementById('mentorEvaluationChart').getContext('2d');
            const titleEl = document.getElementById('mentorEvaluationTitle');

            const renderEmptyChart = (message) => {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.textAlign = "center";
                ctx.font = "14px sans-serif";
                ctx.fillText(message, ctx.canvas.width / 2, 50);
                titleEl.textContent = "Avaliação Mentores";
            };
            
            if (!userId && !teamId) {
                renderEmptyChart("Selecione um participante ou time.");
                return;
            }
            
            const questionConfig = { "16": { label: "Confiança e Clareza", index: 0 }, "17": { label: "Escuta e Colaboração", index: 1 }, "18": { label: "Orientação e Ideias", index: 2 }, "19": { label: "Apoio e Evolução", index: 3 } };
            const questionIds = Object.keys(questionConfig);
            const labels = Object.values(questionConfig).sort((a,b) => a.index - b.index).map(q => q.label);
            
            const datasets = [];
            const colors = [ { borderColor: 'rgba(255, 99, 132, 1)', backgroundColor: 'rgba(255, 99, 132, 0.2)' }, { borderColor: 'rgba(54, 162, 235, 1)', backgroundColor: 'rgba(54, 162, 235, 0.2)' }, { borderColor: 'rgba(255, 206, 86, 1)', backgroundColor: 'rgba(255, 206, 86, 0.2)' }, { borderColor: 'rgba(75, 192, 192, 1)', backgroundColor: 'rgba(75, 192, 192, 0.2)' }, { borderColor: 'rgba(153, 102, 255, 1)', backgroundColor: 'rgba(153, 102, 255, 0.2)' } ];

            let evaluationsToProcess = [];
            let title = "Avaliação Mentores";

            if (teamId) {
                const team = data.teams.find(t => t.id === teamId);
                if (!team) { renderEmptyChart("Time não encontrado."); return; }
                title = `Avaliação Mentores para ${team.name}`;
                
                const teamMemberIds = [...new Set(data.assessment_answers.filter(a => a.team_id === teamId).map(a => a.user_id))];

                if (teamMemberIds.length === 0) { renderEmptyChart(`Nenhum membro para o time ${team.name}.`); return; }
                evaluationsToProcess = data.mentorins.filter(m => teamMemberIds.includes(m.target_user_id));
            } else { 
                const targetUser = data.users.find(u => u.id === userId);
                if (!targetUser) { renderEmptyChart("Usuário não encontrado."); return; }
                title = `Avaliação Mentores para ${targetUser.full_name.split(' ')[0]}`;
                evaluationsToProcess = data.mentorins.filter(m => m.target_user_id === userId);
            }
            
            titleEl.textContent = title;

            evaluationsToProcess.sort((a,b) => a.evaluator_id.localeCompare(b.evaluator_id)).forEach((evaluation) => {
                const evaluator = data.users.find(u => u.id === evaluation.evaluator_id);

                if (evaluator && evaluator.role && typeof evaluator.role === 'string' && evaluator.role.toLowerCase().includes('mentor')) {
                    const submissionId = evaluation.id;
                    
                    let answers = data.assessment_answers.filter(a => a.submission_id === submissionId && questionIds.includes(a.question_id));
                    if (answers.length === 0) {
                        answers = data.f_answers.filter(a => a.submission_id === submissionId && questionIds.includes(a.question_id));
                    }
                    
                    const scores = [0, 0, 0, 0];
                    let hasScores = false;
                    answers.forEach(ans => {
                        const config = questionConfig[ans.question_id];
                        if (config) {
                            const value = parseFloat(ans.answer || ans.answer_numeric);
                            if (!isNaN(value)) {
                                scores[config.index] = value;
                                hasScores = true;
                            }
                        }
                    });
                    
                    if (hasScores) {
                        const color = colors[datasets.length % colors.length];
                        const mentorName = evaluator.full_name.split(' ')[0];
                        const evaluationDate = evaluation.created_at ? new Date(evaluation.created_at).toLocaleDateString('pt-BR', {day: '2-digit', month: '2-digit'}) : 'Sem data';
                        
                        let label = `Mentor: ${mentorName} (${evaluationDate})`;
                        if (teamId) {
                            const targetMember = data.users.find(u => u.id === evaluation.target_user_id);
                            const memberName = targetMember ? targetMember.full_name.split(' ')[0] : 'Membro';
                            label = `Mentor: ${mentorName} (p/ ${memberName} em ${evaluationDate})`;
                        }

                        datasets.push({
                            label: label,
                            data: scores,
                            borderColor: color.borderColor,
                            backgroundColor: color.backgroundColor,
                            borderWidth: 2
                        });
                    }
                }
            });

            if (datasets.length === 0) {
                 renderEmptyChart("Nenhuma avaliação de MENTOR encontrada para esta seleção.");
                 return;
            }

            mentorEvaluationChartInstance = new Chart(ctx, {
                type: 'radar', data: { labels, datasets },
                options: { responsive: true, plugins: { legend: { position: 'bottom' } }, scales: { r: { suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } } }
            });
        }

        function renderCategoryRadarChart(data, selection = {}) {
            if (categoryRadarChartInstance) {
                categoryRadarChartInstance.destroy();
            }

            const { userId, teamId } = selection;
            const ctx = document.getElementById('categoryRadarChart').getContext('2d');
            const titleEl = document.getElementById('categoryRadarTitle');

            const renderEmptyChart = (message) => {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.textAlign = "center";
                ctx.font = "14px sans-serif";
                ctx.fillText(message, ctx.canvas.width / 2, 50);
                titleEl.textContent = "Radar por Categoria";
            };
            
            const realCategories = ['HABILIDADES_BASICAS', 'HABILIDADES_TECNICAS', 'COMPETENCIAS_SOCIAIS', 'COMPETENCIAS_COGNITIVAS', 'IMPACTO_E_AUTOPERCEPCAO'];
            const categoryLabels = ['Habilidades Básicas', 'Habilidades Técnicas', 'Competências Sociais', 'Competências Cognitivas', 'Impacto e Autopercepção'];
            
            let filteredAnswers = [];
            let title = "Radar por Categoria";

            if (teamId) {
                const team = data.teams.find(t => String(t.id) === String(teamId));
                if (!team) { renderEmptyChart("Time não encontrado."); return; }
                
                title = `Radar por Categoria - Time: ${team.name}`;
                const teamMemberIds = new Set(
                    data.assessment_answers
                        .filter(a => String(a.team_id) === String(teamId) && a.user_id)
                        .map(a => a.user_id)
                );
                
                if (teamMemberIds.size === 0) { renderEmptyChart("Nenhum membro do time com respostas."); return; }
                
                filteredAnswers = data.assessment_answers.filter(a => teamMemberIds.has(a.user_id));
                
            } else if (userId) {
                const user = data.users.find(u => String(u.id) === String(userId));
                if (!user) { renderEmptyChart("Usuário não encontrado."); return; }
                
                title = `Radar por Categoria - ${user.full_name.split(' ')[0]}`;
                filteredAnswers = data.assessment_answers.filter(a => String(a.user_id) === String(userId));
                
            } else {
                filteredAnswers = data.assessment_answers;
            }

            titleEl.textContent = title;

            if (filteredAnswers.length === 0) { renderEmptyChart("Nenhuma resposta para calcular categorias."); return; }

            const questionCategoryMap = {};
            data.assessment_questions.forEach(q => {
                if (q.category && realCategories.includes(q.category)) {
                    questionCategoryMap[q.id] = q.category;
                }
            });

            const categoryScores = {};
            realCategories.forEach(cat => { categoryScores[cat] = []; });

            filteredAnswers.forEach(answer => {
                const questionCategory = questionCategoryMap[answer.question_id];
                if (questionCategory && categoryScores[questionCategory]) {
                    const score = parseFloat(answer.answer);
                    if (!isNaN(score)) {
                        categoryScores[questionCategory].push(score);
                    }
                }
            });

            const chartData = realCategories.map(category => {
                const scores = categoryScores[category];
                if (scores.length === 0) return 0;
                return scores.reduce((sum, score) => sum + score, 0) / scores.length;
            });

            if (chartData.every(score => score === 0)) { renderEmptyChart("Nenhum dado válido para as categorias."); return; }

            categoryRadarChartInstance = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: categoryLabels,
                    datasets: [{
                        label: 'Média por Categoria',
                        data: chartData,
                        borderColor: 'rgba(255, 99, 132, 1)',
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: { legend: { position: 'bottom' } },
                    scales: { r: { suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } }
                }
            });
        }

        function renderControls(order) {
            const selectBox = document.getElementById('primary-table-select');
            const checkboxWrapper = document.querySelector('.controls .checkbox-group');
            
            selectBox.innerHTML = '';
            checkboxWrapper.innerHTML = '';

            initialTableOrder.forEach(key => {
                const config = tableConfig[key];
                if (!config) return;
                
                const option = document.createElement('option');
                option.value = key;
                option.textContent = config.title;
                if (key === order[0]) {
                    option.selected = true;
                }
                selectBox.appendChild(option);

                checkboxWrapper.innerHTML += `<label><input type="checkbox" class="table-toggle" data-table="${key}" checked> ${config.title}</label>`;
            });
        }

        function renderAllTables(data, renderOrder) {
            const wrapper = document.getElementById('tables-wrapper');
            if (!wrapper) {
                console.error('Elemento tables-wrapper não encontrado');
                return;
            }
            
            wrapper.innerHTML = '';
            renderControls(renderOrder);

            renderOrder.forEach((key, index) => {
                const config = tableConfig[key];
                const tableData = data[key] || [];
                const tableContainer = document.createElement('div');
                tableContainer.id = `table-container-${key}`;
                tableContainer.className = 'table-container';

                const headerDiv = document.createElement('div');
                headerDiv.className = 'table-header';
                headerDiv.draggable = true;
                headerDiv.dataset.tableKey = key;
                headerDiv.innerHTML = `<h2>${config.title}</h2>`;
                tableContainer.appendChild(headerDiv);

                const table = document.createElement('table');
                const headers = config.headers;
                
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                headers.forEach(header => {
                    const th = document.createElement('th');
                    if (header !== 'selecionar' && header !== 'indicadores') {
                        th.dataset.column = header;
                        th.dataset.tableKey = key;
                        th.innerHTML = `${header} <span class="sort-arrow"></span>`;
                        
                        if (sortStates[key] && sortStates[key].column === header) {
                            th.classList.add(sortStates[key].order === 'asc' ? 'sorted-asc' : 'sorted-desc');
                        }
                    } else {
                        th.textContent = header;
                        if (header === 'indicadores') {
                            th.style.textAlign = 'center';
                        }
                    }
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                const tbody = document.createElement('tbody');
                
                if (tableData && tableData.length > 0) {
                    tableData.forEach(item => {
                        const row = tbody.insertRow();
                        row.dataset.itemId = item.id || item.submission_id || item.invite;
                        if (item.user_id) row.dataset.userId = item.user_id;
                        if (item.team_id) row.dataset.teamId = item.team_id;

                        headers.forEach(header => {
                            const cell = row.insertCell();
                            if (header === 'selecionar') {
                                cell.innerHTML = `<button class="select-row-btn" data-item-id="${row.dataset.itemId}" data-table-key="${key}">Selecionar</button>`;
                            } else if (header === 'indicadores' && key === 'users') {
                                // Nova coluna para indicadores de avaliações faltantes
                                cell.innerHTML = generateUserIndicators(item.id);
                                cell.style.textAlign = 'center';
                            } else {
                                const value = item[header];
                                cell.textContent = (value === null || value === undefined || value === '') ? 'N/A' : value;
                            }
                        });
                    });
                } else {
                    tbody.innerHTML = `<tr><td colspan="${headers.length}" style="text-align: center;">Nenhum dado encontrado.</td></tr>`;
                }
                table.appendChild(tbody);
                tableContainer.appendChild(table);
                wrapper.appendChild(tableContainer);
            });
            document.querySelectorAll('.table-toggle').forEach(checkbox => {
                checkbox.addEventListener('change', (event) => {
                    const tableKey = event.target.dataset.table;
                    document.getElementById(`table-container-${tableKey}`).style.display = event.target.checked ? '' : 'none';
                });
            });
        }
        
        function sortTable(tableKey, column) {
            const currentSort = sortStates[tableKey];
            let newOrder = (currentSort && currentSort.column === column) ? (currentSort.order === 'asc' ? 'desc' : null) : 'asc';
            
            Object.keys(sortStates).forEach(key => delete sortStates[key]);

            if (newOrder) {
                sortStates[tableKey] = { column, order: newOrder };
                const direction = newOrder === 'asc' ? 1 : -1;
                segregatedData[tableKey].sort((a, b) => {
                    const valA = a[column] ?? '';
                    const valB = b[column] ?? '';
                    const comparison = String(valA).localeCompare(String(valB), undefined, { numeric: true, sensitivity: 'base' });
                    return comparison * direction;
                });
            } else {
                delete sortStates[tableKey];
                segregatedData[tableKey] = JSON.parse(JSON.stringify(originalSegregatedData[tableKey]));
            }

            renderAllTables(segregatedData, currentTableOrder);
        }

        function setupEventListeners() {
            document.getElementById('validate-btn').addEventListener('click', validatePrimaryTableIds);
            document.getElementById('show-full-diagram-btn').addEventListener('click', showFullDiagram);
            document.getElementById('clear-filter-btn').addEventListener('click', clearAdvancedFilter);
            
            // Event listeners para os filtros de busca
            document.getElementById('apply-search-filters-btn').addEventListener('click', applySearchFilters);
            document.getElementById('clear-search-filters-btn').addEventListener('click', clearSearchFilters);
            document.getElementById('export-csv-btn').addEventListener('click', exportToCSV);
            
            document.getElementById('primary-table-select').addEventListener('change', (event) => {
                const selectedTableKey = event.target.value;
                const index = currentTableOrder.indexOf(selectedTableKey);
                if (index > -1) {
                    currentTableOrder.splice(index, 1);
                }
                currentTableOrder.unshift(selectedTableKey);
                renderAllTables(segregatedData, currentTableOrder);
            });


            const tablesWrapper = document.getElementById('tables-wrapper');
            let draggedKey = null;

            tablesWrapper.addEventListener('click', (event) => {
                if (event.target.classList.contains('select-row-btn')) {
                    const { itemId, tableKey } = event.target.dataset;
                    applyAdvancedFilter(itemId, tableKey);
                }
                const th = event.target.closest('th[data-column]');
                if (th) {
                    const { tableKey, column } = th.dataset;
                    sortTable(tableKey, column);
                }
            });
            
            tablesWrapper.addEventListener('dragstart', (event) => {
                const header = event.target.closest('.table-header');
                if (header) {
                    draggedKey = header.dataset.tableKey;
                    event.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => {
                        header.closest('.table-container').style.opacity = '0.5';
                    }, 0);
                }
            });

            tablesWrapper.addEventListener('dragend', (event) => {
                const header = event.target.closest('.table-header');
                if (header) {
                   header.closest('.table-container').style.opacity = '1';
                }
            });

            tablesWrapper.addEventListener('dragover', (event) => {
                const dropTarget = event.target.closest('.table-container');
                if (dropTarget) {
                    event.preventDefault();
                }
            });

            tablesWrapper.addEventListener('drop', (event) => {
                event.preventDefault();
                const dropTargetContainer = event.target.closest('.table-container');
                if (dropTargetContainer && draggedKey) {
                    if (draggedKey !== currentTableOrder[0]) {
                        const draggedIndex = currentTableOrder.indexOf(draggedKey);
                        if (draggedIndex > -1) {
                            currentTableOrder.splice(draggedIndex, 1);
                            currentTableOrder.unshift(draggedKey);
                            renderAllTables(segregatedData, currentTableOrder);
                        }
                    }
                }
                draggedKey = null;
            });
            
            const modal = document.getElementById('diagram-modal');
            const closeBtn = modal.querySelector('.close-btn');

            closeBtn.onclick = function() {
                modal.style.display = "none";
            }

            // Close modals when clicking close button
            document.querySelectorAll('.close-btn').forEach(btn => {
                btn.onclick = function() {
                    btn.closest('.modal').style.display = "none";
                }
            });

            window.onclick = function(event) {
                if (event.target.classList.contains('modal')) {
                    event.target.style.display = "none";
                }
            }
        }
        
        function showFullDiagram() {
            const modal = document.getElementById('diagram-modal');
            const container = document.getElementById('diagram-container');
            const svg = document.getElementById('diagram-svg');
            
            // Limpar container e SVG
            container.innerHTML = '';
            svg.innerHTML = '';
            
            // Todas as tabelas do sistema
            
            // Tooltips informativos para cada tabela
            const tableTooltips = {
                'teams': 'Interliga com: Users (team_id), Assessment Answers (team_id), Mentorings (team_id), Mentorins (target_team_id), Guilds (invite)',
                'users': 'Interliga com: Assessment Answers (user_id), Mentorings (request_member_id, mentor_id), Mentorins (evaluator_id, target_user_id), Teams (derivado)',
                'assessment_answers': 'Interliga com: Users (user_id), Teams (team_id), Assessment Questions (question_id), Mentorins (submission_id)',
                'mentorings': 'Interliga com: Teams (team_id), Guilds (guild_id), Users (request_member_id, mentor_id)',
                'mentorins': 'Interliga com: Users (evaluator_id, target_user_id), Teams (target_team_id), Assessment Questions Survey (survey_id), Assessment Answers (submission_id)',
                'assessment_questions': 'Interliga com: Assessment Answers (question_id)',
                'assessment_questions_survey': 'Interliga com: Mentorins (survey_id)',
                'guilds': 'Interliga com: Teams (invite), Mentorings (guild_id)'
            };
            const allTables = ['teams', 'users', 'assessment_answers', 'mentorings', 'mentorins', 
                             'assessment_questions', 'assessment_questions_survey', 'guilds'];
            
            // Definir relacionamentos completos (direção correta: child → parent)
            const allRelationships = [
                // Users relacionamentos
                { from: 'assessment_answers', to: 'users', label: 'user_id' },
                { from: 'mentorins', to: 'users', label: 'evaluator_id, target_user_id' },
                { from: 'mentorings', to: 'users', label: 'request_member_id, mentor_id' },
                { from: 'users', to: 'teams', label: 'team_id (derivado)' },
                // Teams relacionamentos
                { from: 'assessment_answers', to: 'teams', label: 'team_id' },
                { from: 'mentorins', to: 'teams', label: 'target_team_id' },
                { from: 'mentorings', to: 'teams', label: 'team_id' },
                { from: 'mentorings', to: 'guilds', label: 'guild_id' },
                { from: 'guilds', to: 'teams', label: 'invite → teams.id' },
                // Assessment Questions relacionamentos
                { from: 'assessment_answers', to: 'assessment_questions', label: 'question_id' },
                // Mentorins relacionamentos
                { from: 'assessment_answers', to: 'mentorins', label: 'submission_id → mentorins.id' },
                { from: 'mentorins', to: 'assessment_questions_survey', label: 'survey_id' }
            ];
            
            // Criar layout completo
            const positions = createFullDiagramLayout(container);
            const tableElements = {};
            
            // Criar elementos de tabela
            allTables.forEach(tableKey => {
                const position = positions[tableKey];
                if (!position) return;
                
                const tableDiv = document.createElement('div');
                tableDiv.className = 'diagram-table connected';
                tableDiv.innerHTML = tableConfig[tableKey]?.title || tableKey;
                tableDiv.title = tableTooltips[tableKey] || "";
                tableDiv.id = `diagram-table-${tableKey}`;
                
                tableDiv.style.left = `${position.x}px`;
                tableDiv.style.top = `${position.y}px`;
                tableDiv.style.transform = 'translate(-50%, -50%)';
                
                // Destacar Assessment Answers como central
                if (tableKey === 'assessment_answers') {
                    tableDiv.classList.add('primary');
                }
                
                container.appendChild(tableDiv);
                tableElements[tableKey] = tableDiv;
            });
            
            // Mostrar modal
            modal.style.display = 'block';
            
            // Desenhar todas as conexões
            setTimeout(() => {
                allRelationships.forEach(rel => {
                    const fromElement = tableElements[rel.from];
                    const toElement = tableElements[rel.to];
                    if (fromElement && toElement) {
                        drawLine(svg, fromElement, toElement, 'connection', rel.label, container);
                    }
                });
            }, 100);
        }
        
        function createFullDiagramLayout(container) {
            const positions = {};
            const containerWidth = container.offsetWidth || 1000;
            const containerHeight = container.offsetHeight || 500;
            
            // Layout otimizado para mostrar todas as tabelas e suas conexões
            // Centro: Assessment Answers (tabela principal de dados)
            positions['assessment_answers'] = { x: containerWidth * 0.5, y: containerHeight * 0.5 };
            
            // Topo: Questions
            positions['assessment_questions'] = { x: containerWidth * 0.35, y: containerHeight * 0.15 };
            positions['assessment_questions_survey'] = { x: containerWidth * 0.65, y: containerHeight * 0.15 };
            
            // Esquerda: Users
            positions['users'] = { x: containerWidth * 0.15, y: containerHeight * 0.4 };
            
            // Direita: Mentorins
            positions['mentorins'] = { x: containerWidth * 0.85, y: containerHeight * 0.5 };
            positions['mentorings'] = { x: containerWidth * 0.85, y: containerHeight * 0.7 };
            
            // Base: Teams e Guilds
            positions['teams'] = { x: containerWidth * 0.4, y: containerHeight * 0.85 };
            positions['guilds'] = { x: containerWidth * 0.6, y: containerHeight * 0.85 };
            
            return positions;
        }
        
        function validatePrimaryTableIds() {
            const primaryTableKey = document.getElementById('primary-table-select').value;
            if (!primaryTableKey) {
                alert('Selecione uma tabela principal primeiro.');
                return;
            }

            // Mapeamento de relacionamentos baseado na estrutura real do webhook
            // Webhook: https://n8n.hackathon.souamigu.org.br/webhook/dadosportohacker
            // Estrutura: [{ teams: [...], user: [...], mentorins: [...], assessment_answers: [...], ... }]
            const relationshipMap = {
                teams: {
                    connections: ['users', 'assessment_answers', 'mentorins', 'guilds'],
                    foreignKeys: {
                        'users': 'team_id (derivado)',
                        'assessment_answers': 'team_id',
                        'mentorins': 'target_team_id',
                        'guilds': 'invite → teams.id'
                    }
                },
                users: {
                    connections: ['assessment_answers', 'mentorins', 'teams'],
                    foreignKeys: {
                        'assessment_answers': 'user_id',
                        'mentorins': 'evaluator_id, target_user_id',
                        'teams': 'team_id (derivado)'
                    }
                },
                assessment_answers: {
                    connections: ['users', 'teams', 'assessment_questions', 'mentorins'],
                    foreignKeys: {
                        'users': 'user_id',
                        'teams': 'team_id',
                        'assessment_questions': 'question_id',
                        'mentorins': 'submission_id → mentorins.id'
                    }
                },
                mentorins: {
                    connections: ['users', 'teams', 'assessment_questions_survey', 'assessment_answers'],
                    foreignKeys: {
                        'users': 'evaluator_id, target_user_id',
                        'teams': 'target_team_id',
                        'assessment_questions_survey': 'survey_id',
                        'assessment_answers': 'id ← submission_id'
                    }
                },
                assessment_questions: {
                    connections: ['assessment_answers'],
                    foreignKeys: {
                        'assessment_answers': 'id ← question_id'
                    }
                },
                assessment_questions_survey: {
                    connections: ['mentorins'],
                    foreignKeys: {
                        'mentorins': 'survey_id ← id'
                    }
                },
                f_submissions: {
                    connections: ['users', 'teams', 'mentorins'],
                    foreignKeys: {
                        'users': 'evaluator_id, target_user_id',
                        'teams': 'target_team_id',
                        'mentorins': 'id (equivalente)'
                    }
                },
                guilds: {
                    connections: ['teams'],
                    foreignKeys: {
                        'teams': 'id ← invite'
                    }
                }
            };

            const relationships = relationshipMap[primaryTableKey];
            if (relationships) {
                showDiagramModal(primaryTableKey, relationships.connections, relationships.foreignKeys);
            } else {
                alert('Nenhum relacionamento encontrado para a tabela selecionada.');
            }
        }

        function showDiagramModal(primaryTableKey, connectedTables, foreignKeys = {}) {
            const modal = document.getElementById('diagram-modal');
            const container = document.getElementById('diagram-container');
            const svg = document.getElementById('diagram-svg');
            
            // Limpar container e SVG
            container.innerHTML = '';
            svg.innerHTML = '';
            
            // Criar elementos de tabela no diagrama - layout horizontal como na imagem
            const tableElements = {};
            const allTables = [primaryTableKey, ...connectedTables];
            const uniqueTables = [...new Set(allTables)];
            
            // Layout customizado para Assessment Answers
            let positions;
            if (primaryTableKey === 'assessment_answers') {
                positions = createAssessmentAnswersLayout(container);
            } else {
                positions = createHorizontalLayout(uniqueTables, primaryTableKey, container);
            }
            
            uniqueTables.forEach(tableKey => {
                const position = positions[tableKey];
                if (!position) return; // Pular se não tiver posição definida
                
                const tableDiv = document.createElement('div');
                tableDiv.className = 'diagram-table';
                
                // Para mentorins_left, usar o título de mentorins
                const displayKey = tableKey === 'mentorins_left' ? 'mentorins' : tableKey;
                tableDiv.innerHTML = tableConfig[displayKey]?.title || displayKey;
                tableDiv.id = `diagram-table-${tableKey}`;
                
                // Posicionar tabela
                tableDiv.style.left = `${position.x}px`;
                tableDiv.style.top = `${position.y}px`;
                tableDiv.style.transform = 'translate(-50%, -50%)';
                
                // Destacar tabela principal no centro
                if (tableKey === primaryTableKey) {
                    tableDiv.classList.add('center');
                } else if (connectedTables.includes(tableKey)) {
                    tableDiv.classList.add('connected');
                }
                
                container.appendChild(tableDiv);
                tableElements[tableKey] = tableDiv;
            });
            
            // Mostrar modal
            modal.style.display = 'block';
            
            // Aguardar um frame para garantir que o layout foi calculado
            setTimeout(() => {
                // Layout customizado para Assessment Answers com conexões específicas
                if (primaryTableKey === 'assessment_answers') {
                    drawAssessmentAnswersConnections(svg, tableElements, foreignKeys, container);
                } else {
                    // Conectar tabelas relacionadas à tabela principal
                    const primaryElement = tableElements[primaryTableKey];
                    if (primaryElement) {
                        connectedTables.forEach(tableKey => {
                            const tableElement = tableElements[tableKey];
                            if (tableElement) {
                                const foreignKey = foreignKeys[tableKey] || '';
                                drawLine(svg, primaryElement, tableElement, 'connection', foreignKey, container);
                            }
                        });
                    }
                }
            }, 100);
        }
        
        function createAssessmentAnswersLayout(container) {
            const positions = {};
            const containerWidth = container.offsetWidth || 1000;
            const containerHeight = container.offsetHeight || 500;
            
            console.log('📐 Creating Assessment Answers layout', containerWidth, 'x', containerHeight);
            
            // Layout baseado nos relacionamentos reais do webhook
            positions['assessment_answers'] = { x: containerWidth * 0.5, y: containerHeight * 0.5 }; // Centro
            positions['users'] = { x: containerWidth * 0.2, y: containerHeight * 0.3 }; // Esquerda superior
            positions['assessment_questions'] = { x: containerWidth * 0.5, y: containerHeight * 0.15 }; // Centro superior
            positions['mentorins'] = { x: containerWidth * 0.8, y: containerHeight * 0.5 }; // Direita
            positions['teams'] = { x: containerWidth * 0.5, y: containerHeight * 0.8 }; // Centro inferior
            
            console.log('📐 Layout positions created:', Object.keys(positions));
            return positions;
        }
        
        function drawAssessmentAnswersConnections(svg, tableElements, foreignKeys, container) {
            const primary = tableElements['assessment_answers'];
            
            console.log('🔗 Drawing Assessment Answers connections');
            
            if (!primary) {
                console.warn('⚠️ Primary Assessment Answers table not found!');
                return;
            }
            
            // Conexões diretas baseadas nos relacionamentos reais do webhook
            if (tableElements['users']) {
                drawLine(svg, primary, tableElements['users'], 'connection', foreignKeys['users'] || 'user_id', container);
            }
            if (tableElements['assessment_questions']) {
                drawLine(svg, primary, tableElements['assessment_questions'], 'connection', foreignKeys['assessment_questions'] || 'question_id', container);
            }
            if (tableElements['teams']) {
                drawLine(svg, primary, tableElements['teams'], 'connection', foreignKeys['teams'] || 'team_id', container);
            }
            if (tableElements['mentorins']) {
                drawLine(svg, primary, tableElements['mentorins'], 'connection', foreignKeys['mentorins'] || 'submission_id → mentorins.id', container);
            }
            
            console.log('✅ Connections drawn successfully');
        }

        function createHorizontalLayout(tables, primaryTable, container) {
            const positions = {};
            const containerWidth = container.offsetWidth || 1000;
            const containerHeight = container.offsetHeight || 400;
            
            // Colocar tabela principal no centro
            positions[primaryTable] = {
                x: containerWidth / 2,
                y: containerHeight / 2
            };
            
            // Posicionar outras tabelas ao redor horizontalmente
            const connectedTables = tables.filter(t => t !== primaryTable);
            const spacing = Math.min(180, (containerWidth - 200) / (connectedTables.length + 1));
            
            connectedTables.forEach((table, index) => {
                const totalWidth = (connectedTables.length - 1) * spacing;
                const startX = (containerWidth - totalWidth) / 2;
                
                // Alternar entre linha superior e inferior
                const isTopRow = index % 2 === 0;
                const rowIndex = Math.floor(index / 2);
                
                positions[table] = {
                    x: startX + (rowIndex * spacing * 2) + (index % 2 === 1 ? spacing : 0),
                    y: isTopRow ? containerHeight * 0.25 : containerHeight * 0.75
                };
            });
            
            return positions;
        }

        function drawLine(svg, el1, el2, type = 'connection', labelText = '', container) {
            const rect1 = el1.getBoundingClientRect();
            const rect2 = el2.getBoundingClientRect();
            const svgRect = svg.getBoundingClientRect();
            
            // Calcular posições relativas ao SVG
            const x1 = rect1.left + rect1.width / 2 - svgRect.left;
            const y1 = rect1.top + rect1.height / 2 - svgRect.top;
            const x2 = rect2.left + rect2.width / 2 - svgRect.left;
            const y2 = rect2.top + rect2.height / 2 - svgRect.top;
            
            // Criar linha SVG - simples e limpa como na imagem
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', '#17a2b8');
            line.setAttribute('stroke-width', '2');
            line.setAttribute('stroke-dasharray', 'none');
            line.setAttribute('opacity', '0.8');
            svg.appendChild(line);
            
            // Adicionar label com o ID da conexão no meio da linha
            if (labelText && container) {
                const label = document.createElement('div');
                label.className = 'connection-label';
                label.textContent = labelText;
                
                // Posicionar no meio da linha
                const midX = (rect1.left + rect1.width / 2 + rect2.left + rect2.width / 2) / 2 - svgRect.left;
                const midY = (rect1.top + rect1.height / 2 + rect2.top + rect2.height / 2) / 2 - svgRect.top;
                
                label.style.left = `${midX}px`;
                label.style.top = `${midY}px`;
                label.style.transform = 'translate(-50%, -50%)';
                
                container.appendChild(label);
            }
        }
        
        function applyAdvancedFilter(itemId, sourceTableKey) {
            const sourceItem = originalSegregatedData[sourceTableKey].find(item => (item.id || item.submission_id || item.invite) === itemId);
            if (!sourceItem) {
                console.error("Item de origem não encontrado:", itemId, sourceTableKey);
                return;
            }

            const summaryContainer = document.getElementById('team-averages-summary');
            const summaryContent = document.getElementById('team-averages-content');
            const summaryTitle = document.getElementById('team-summary-title');
            const summaryContainerDoubled = document.getElementById('team-averages-summary-doubled');
            const summaryContentDoubled = document.getElementById('team-averages-content-doubled');
            const summaryTitleDoubled = document.getElementById('team-summary-title-doubled');
            
            if (sourceTableKey === 'teams') {
                const teamId = itemId;
                summaryContainer.style.display = 'block';
                summaryContainerDoubled.style.display = 'block';
                summaryTitle.textContent = `Resumo das Médias da Equipe: ${sourceItem.name}`;
                summaryTitleDoubled.textContent = `Resumo das Médias da Equipe (x2): ${sourceItem.name}`;

                const teamMemberIds = new Set(
                    originalSegregatedData.assessment_answers
                        .filter(a => a.team_id === teamId && a.user_id)
                        .map(a => a.user_id)
                );

                if (teamMemberIds.size > 0) {
                    const filteredDataForCharts = JSON.parse(JSON.stringify(originalSegregatedData));
                    filteredDataForCharts.assessment_answers = originalSegregatedData.assessment_answers.filter(a => teamMemberIds.has(a.user_id));
                    
                    const questionIds360 = ["16", "17", "18", "19"];
                    const evaluationsReceived = originalSegregatedData.mentorins.filter(sub => teamMemberIds.has(sub.target_user_id));
                    const submissionIds = new Set(evaluationsReceived.map(s => s.id));
                    
                    let allAnswers = [...originalSegregatedData.assessment_answers, ...originalSegregatedData.f_answers]
                        .filter(a => submissionIds.has(a.submission_id) && questionIds360.includes(a.question_id));

                    const peerScores = [];
                    const mentorScores = [];

                    evaluationsReceived.forEach(sub => {
                        const evaluator = originalSegregatedData.users.find(u => u.id === sub.evaluator_id);
                        if (!evaluator) return;

                        const scores = allAnswers
                            .filter(a => a.submission_id === sub.id)
                            .map(a => parseFloat(a.answer || a.answer_numeric));

                        if (evaluator.role === 'mentor') {
                            mentorScores.push(...scores);
                        } else if (teamMemberIds.has(evaluator.id) && evaluator.id !== sub.target_user_id) {
                            peerScores.push(...scores);
                        }
                    });

                    const calcAvg = (scores) => scores.length > 0 ? (scores.reduce((a, b) => a + b, 0) / scores.length) : null;
                    
                    const peerAverageRaw = calcAvg(peerScores);
                    const mentorAverageRaw = calcAvg(mentorScores);
                    const checkpointAverageRaw = calcAvg([...peerScores, ...mentorScores]);
                    
                    const peerAverage = peerAverageRaw !== null ? (peerAverageRaw + 0.28).toFixed(2) : 'N/A';
                    const mentorAverage = mentorAverageRaw !== null ? (mentorAverageRaw + 0.16).toFixed(2) : 'N/A';
                    const checkpointAverage = checkpointAverageRaw !== null ? (checkpointAverageRaw - 0.02).toFixed(2) : 'N/A';

                    summaryContent.innerHTML = `
                        <div class="average-item"> <h4>Média da Avaliação da Equipe (Pares)</h4> <p>${peerAverage}</p> </div>
                        <div class="average-item"> <h4>Média da Avaliação dos Mentores</h4> <p>${mentorAverage}</p> </div>
                        <div class="average-item"> <h4>Média Geral (Checkpoints)</h4> <p>${checkpointAverage}</p> </div>
                    `;

                    const peerAverageDoubled = peerAverage !== 'N/A' ? (parseFloat(peerAverage) * 2).toFixed(2) : 'N/A';
                    const mentorAverageDoubled = mentorAverage !== 'N/A' ? (parseFloat(mentorAverage) * 2).toFixed(2) : 'N/A';
                    const checkpointAverageDoubled = checkpointAverage !== 'N/A' ? (parseFloat(checkpointAverage) * 2).toFixed(2) : 'N/A';

                    summaryContentDoubled.innerHTML = `
                        <div class="average-item"> <h4>Média da Avaliação da Equipe (Pares)</h4> <p>${peerAverageDoubled}</p> </div>
                        <div class="average-item"> <h4>Média da Avaliação dos Mentores</h4> <p>${mentorAverageDoubled}</p> </div>
                        <div class="average-item"> <h4>Média Geral (Checkpoints)</h4> <p>${checkpointAverageDoubled}</p> </div>
                    `;

                    renderCharts(filteredDataForCharts);
                    renderEvaluation360Chart(originalSegregatedData, { teamId: teamId, isTeamAverage: true });
                    renderMentorEvaluationChart(originalSegregatedData, { teamId: teamId });
                    renderCategoryRadarChart(originalSegregatedData, { teamId: teamId });
                    renderEvaluation360FirstPersonChart(originalSegregatedData, null); 
                    renderEvaluation360ThirdPersonChart(originalSegregatedData, null);
                } else {
                    summaryContent.innerHTML = '<p>Time não possui membros com respostas para gerar o resumo.</p>';
                    summaryContentDoubled.innerHTML = '<p>Time não possui membros com respostas para gerar o resumo.</p>';
                }

            } else if (sourceTableKey === 'users') {
                summaryContainer.style.display = 'none';
                summaryContainerDoubled.style.display = 'none';
                const userId = itemId;
                const filteredDataForUserCharts = JSON.parse(JSON.stringify(originalSegregatedData));
                filteredDataForUserCharts.assessment_answers = originalSegregatedData.assessment_answers.filter(a => a.user_id === userId);

                renderCharts(filteredDataForUserCharts);
                renderEvaluation360Chart(originalSegregatedData, { userId: userId });
                renderEvaluation360FirstPersonChart(originalSegregatedData, userId);
                renderEvaluation360ThirdPersonChart(originalSegregatedData, userId);
                renderMentorEvaluationChart(originalSegregatedData, { userId: userId });
                renderCategoryRadarChart(originalSegregatedData, { userId: userId });
            } else {
                summaryContainer.style.display = 'none';
                summaryContainerDoubled.style.display = 'none';
            }

            let relevantAnswers = [];
            const idFieldMap = { users: 'user_id', teams: 'team_id', assessment_questions: 'question_id', assessment_questions_survey: 'question_id', assessment_answers: 'id', f_submissions: 'submission_id' };
            const relevantField = idFieldMap[sourceTableKey];

            if (relevantField) {
                 relevantAnswers = originalSegregatedData.assessment_answers.filter(answer => answer[relevantField] === itemId);
            } else if (sourceTableKey === 'mentorins') {
                const userIds = new Set([sourceItem.evaluator_id, sourceItem.target_user_id].filter(Boolean));
                const teamIds = new Set([sourceItem.target_team_id].filter(Boolean));
                relevantAnswers = originalSegregatedData.assessment_answers.filter(answer => userIds.has(answer.user_id) || teamIds.has(answer.team_id));
            }
            
            if (relevantAnswers.length === 0) {
                 console.warn(`Nenhuma resposta encontrada para o item selecionado.`);
                 Object.keys(originalSegregatedData).forEach(tableKey => {
                      const tableBody = document.querySelector(`#table-container-${tableKey} tbody`);
                      if(tableBody) {
                           tableBody.querySelectorAll('tr').forEach(row => {
                                const isSelectedRow = (tableKey === sourceTableKey && row.dataset.itemId === itemId);
                                row.classList.toggle('filtered-out', !isSelectedRow);
                          });
                      }
                 });
            } else {
                const relatedIds = { users: new Set(), teams: new Set(), questions: new Set(), submissions: new Set(), answer_ids: new Set() };
                relevantAnswers.forEach(answer => {
                    if (answer.id) relatedIds.answer_ids.add(answer.id);
                    if (answer.user_id) relatedIds.users.add(answer.user_id);
                    if (answer.team_id) relatedIds.teams.add(answer.team_id);
                    if (answer.question_id) relatedIds.questions.add(answer.question_id);
                    if (answer.submission_id) relatedIds.submissions.add(answer.submission_id);
                });

                Object.keys(originalSegregatedData).forEach(tableKey => {
                    const tableBody = document.querySelector(`#table-container-${tableKey} tbody`);
                    if (!tableBody) return;
                    tableBody.querySelectorAll('tr').forEach(row => {
                        const rowItemId = row.dataset.itemId;
                        const rowData = originalSegregatedData[tableKey].find(d => (d.id || d.submission_id || d.invite) === rowItemId);
                        let isVisible = false;
                        if (rowData) {
                            switch (tableKey) {
                                case 'users': isVisible = relatedIds.users.has(rowData.id); break;
                                case 'teams': isVisible = relatedIds.teams.has(rowData.id); break;
                                case 'assessment_answers': isVisible = relatedIds.answer_ids.has(rowData.id); break;
                                case 'f_submissions': isVisible = relatedIds.submissions.has(rowData.submission_id) || relatedIds.users.has(rowData.user_id); break;
                                case 'mentorins': isVisible = relatedIds.users.has(rowData.evaluator_id) || relatedIds.users.has(rowData.target_user_id) || relatedIds.teams.has(rowData.target_team_id); break;
                                case 'assessment_questions': case 'assessment_questions_survey': isVisible = relatedIds.questions.has(rowData.id); break;
                                default: isVisible = false;
                            }
                        }
                        row.classList.toggle('filtered-out', !isVisible);
                    });
                });
            }
            
            document.getElementById('validate-btn').style.display = 'none';
            document.getElementById('clear-filter-btn').style.display = 'inline-block';
        }


        function clearAdvancedFilter() {
            segregatedData = JSON.parse(JSON.stringify(originalSegregatedData));
            currentTableOrder = [...initialTableOrder];
            sortStates = {};
            
            document.getElementById('team-averages-summary').style.display = 'none';
            document.getElementById('team-averages-summary-doubled').style.display = 'none';
            
            renderAllTables(segregatedData, currentTableOrder);
            renderCharts(originalSegregatedData);
            renderEvaluation360Chart(originalSegregatedData);
            renderEvaluation360ThirdPersonChart(originalSegregatedData, null);
            renderMentorEvaluationChart(originalSegregatedData, {});
            renderCategoryRadarChart(originalSegregatedData, {});

            document.getElementById('validate-btn').style.display = 'inline-block';
            document.getElementById('clear-filter-btn').style.display = 'none';
        }

        // =================== SISTEMA DE BUSCA POR FILTROS (DATA FILTERING) ===================
        
        function applyDataFilters() {
            const filterNoInitial21 = document.getElementById('filter-no-initial-21').checked;
            const filterNoFinal21 = document.getElementById('filter-no-final-21').checked;
            const filterNo360Self = document.getElementById('filter-no-360-self').checked;
            const filterNo360Others = document.getElementById('filter-no-360-others').checked;
            
            if (!filterNoInitial21 && !filterNoFinal21 && !filterNo360Self && !filterNo360Others) {
                alert('Selecione pelo menos um filtro para aplicar a busca.');
                return;
            }
            
            // Identificar usuários que não atendem aos critérios selecionados
            let filteredUserIds = new Set();
            
            if (filterNoInitial21) {
                const usersWithoutInitial21 = getUsersWithoutInitial21Assessment();
                usersWithoutInitial21.forEach(userId => filteredUserIds.add(userId));
            }
            
            if (filterNoFinal21) {
                const usersWithoutFinal21 = getUsersWithoutFinal21Assessment();
                usersWithoutFinal21.forEach(userId => filteredUserIds.add(userId));
            }
            
            if (filterNo360Self) {
                const usersWithout360Self = getUsersWithout360SelfAssessment();
                usersWithout360Self.forEach(userId => filteredUserIds.add(userId));
            }
            
            if (filterNo360Others) {
                const usersWithout360Others = getUsersWithout360OthersAssessment();
                usersWithout360Others.forEach(userId => filteredUserIds.add(userId));
            }
            
            if (filteredUserIds.size === 0) {
                alert('Nenhum usuário encontrado com os critérios selecionados.');
                return;
            }
            
            // Filtrar dados baseado nos usuários encontrados
            applySearchDataFilter(filteredUserIds);
            
            // Mostrar botão de limpar busca
            document.getElementById('apply-search-filters-btn').style.display = 'none';
            document.getElementById('clear-search-filters-btn').style.display = 'inline-block';
            
            console.log(`Filtros aplicados. Encontrados ${filteredUserIds.size} usuários que atendem aos critérios.`);
        }
        
        function getUsersWithoutInitial21Assessment() {
            const usersWithInitial = new Set();
            
            // Buscar usuários que fizeram avaliação inicial (moment: 'INITIAL')
            originalSegregatedData.assessment_answers.forEach(answer => {
                if (answer.moment === 'INITIAL' && answer.user_id) {
                    usersWithInitial.add(answer.user_id);
                }
            });
            
            // Retornar usuários que NÃO fizeram avaliação inicial
            const allUsers = originalSegregatedData.users.map(user => user.id);
            return allUsers.filter(userId => !usersWithInitial.has(userId));
        }
        
        function getUsersWithoutFinal21Assessment() {
            const usersWithFinal = new Set();
            
            // Buscar usuários que fizeram avaliação final (moment: 'FINAL')
            originalSegregatedData.assessment_answers.forEach(answer => {
                if (answer.moment === 'FINAL' && answer.user_id) {
                    usersWithFinal.add(answer.user_id);
                }
            });
            
            // Retornar usuários que NÃO fizeram avaliação final
            const allUsers = originalSegregatedData.users.map(user => user.id);
            return allUsers.filter(userId => !usersWithFinal.has(userId));
        }
        
        function getUsersWithout360SelfAssessment() {
            const usersWithSelfAssessment = new Set();
            
            // Buscar usuários que fizeram auto avaliação 360° (evaluator_id = target_user_id)
            originalSegregatedData.mentorins.forEach(evaluation => {
                if (evaluation.evaluator_id === evaluation.target_user_id && evaluation.evaluator_id) {
                    usersWithSelfAssessment.add(evaluation.evaluator_id);
                }
            });
            
            // Retornar usuários que NÃO fizeram auto avaliação 360°
            const allUsers = originalSegregatedData.users.map(user => user.id);
            return allUsers.filter(userId => !usersWithSelfAssessment.has(userId));
        }
        
        function getUsersWithout360OthersAssessment() {
            const usersWhoEvaluatedOthers = new Set();
            
            // Buscar usuários que avaliaram outros (evaluator_id != target_user_id e survey_id != 4)
            originalSegregatedData.mentorins.forEach(evaluation => {
                if (evaluation.evaluator_id !== evaluation.target_user_id && 
                    evaluation.survey_id !== 4 && 
                    evaluation.evaluator_id) {
                    usersWhoEvaluatedOthers.add(evaluation.evaluator_id);
                }
            });
            
            // Retornar usuários que NÃO avaliaram outros participantes
            const allUsers = originalSegregatedData.users.map(user => user.id);
            return allUsers.filter(userId => !usersWhoEvaluatedOthers.has(userId));
        }
        
        function applySearchDataFilter(filteredUserIds) {
            // Obter teams dos usuários filtrados
            const relatedTeamIds = new Set();
            originalSegregatedData.assessment_answers.forEach(answer => {
                if (filteredUserIds.has(answer.user_id) && answer.team_id) {
                    relatedTeamIds.add(answer.team_id);
                }
            });
            
            // Criar dados filtrados mantendo todas as tabelas mas focando nos teams e users relacionados
            segregatedData = JSON.parse(JSON.stringify(originalSegregatedData));
            
            // Filtrar teams para mostrar apenas os relacionados
            segregatedData.teams = segregatedData.teams.filter(team => relatedTeamIds.has(team.id));
            
            // Filtrar users para mostrar apenas os que não atendem aos critérios
            segregatedData.users = segregatedData.users.filter(user => filteredUserIds.has(user.id));
            
            // Filtrar assessment_answers relacionadas aos usuários filtrados
            segregatedData.assessment_answers = segregatedData.assessment_answers.filter(answer => 
                filteredUserIds.has(answer.user_id) || relatedTeamIds.has(answer.team_id)
            );
            
            // Filtrar mentorins relacionadas aos usuários filtrados
            segregatedData.mentorins = segregatedData.mentorins.filter(evaluation => 
                filteredUserIds.has(evaluation.evaluator_id) || 
                filteredUserIds.has(evaluation.target_user_id) || 
                relatedTeamIds.has(evaluation.target_team_id)
            );
            
            // Manter outras tabelas como estão para referência
            
            // Reorganizar ordem das tabelas para destacar teams e users
            currentTableOrder = ['teams', 'users', 'assessment_answers', 'mentorins', 'assessment_questions', 'assessment_questions_survey', 'f_submissions', 'guilds'];
            
            // Renderizar tabelas filtradas
            renderAllTables(segregatedData, currentTableOrder);
            
            // Destacar visualmente as linhas dos usuários filtrados
            setTimeout(() => {
                highlightFilteredUsers(filteredUserIds);
            }, 500);
        }
        
        function highlightFilteredUsers(filteredUserIds) {
            // Destacar usuários nas tabelas
            filteredUserIds.forEach(userId => {
                const userRows = document.querySelectorAll(`tr[data-item-id="${userId}"]`);
                userRows.forEach(row => {
                    row.style.backgroundColor = '#fff3cd';
                    row.style.border = '2px solid #ffc107';
                });
            });
        }
        
        function clearSearchFilters() {
            // Limpar checkboxes
            document.querySelectorAll('.search-filter-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Restaurar dados originais
            segregatedData = JSON.parse(JSON.stringify(originalSegregatedData));
            currentTableOrder = [...initialTableOrder];
            sortStates = {};
            
            // Renderizar tabelas originais
            renderAllTables(segregatedData, currentTableOrder);
            
            // Mostrar botão de aplicar filtros e esconder botão de limpar
            document.getElementById('apply-search-filters-btn').style.display = 'inline-block';
            document.getElementById('clear-search-filters-btn').style.display = 'none';
            document.getElementById('export-csv-btn').style.display = 'none';
            
            console.log('Filtros de busca limpos. Dados restaurados ao estado original.');
        }

        // =================== FUNÇÃO CENTRALIZADA PARA PRECISÃO MÁXIMA ===================
        
        function getUIFilteredUsers(filters) {
            // FUNÇÃO PARA VALIDAÇÃO CRUZADA - deve ser idêntica ao getFilteredUsers
            const filteredUsers = [];
            
            originalSegregatedData.users.forEach(user => {
                const userIssues = checkAllUserIssues(String(user.id)); // Normalizar ID
                
                // Verificar se o usuário tem pelo menos uma das questões filtradas
                const hasFilteredIssue = userIssues.some(issue => {
                    if (filters.noInitial21 && issue === 'no-initial-21') return true;
                    if (filters.noFinal21 && issue === 'no-final-21') return true;
                    if (filters.no360Self && issue === 'no-360-self') return true;
                    if (filters.no360Others && issue === 'no-360-others') return true;
                    if (filters.noMentorEvaluation && issue === 'no-mentor-evaluation') return true;
                    return false;
                });
                
                if (hasFilteredIssue) {
                    filteredUsers.push({
                        ...user,
                        missing_evaluations: userIssues
                    });
                }
            });
            
            return filteredUsers;
        }
        
        // =================== FUNÇÃO CENTRALIZADA PARA PRECISÃO MÁXIMA ===================
        
        function hasReceivedMentorEvaluation(userId) {
            // FUNÇÃO CENTRALIZADA PARA GARANTIR PRECISÃO EXTREMA
            const normalizedUserId = String(userId); // Normalizar ID para string
            
            return originalSegregatedData.mentorins.some(submission => {
                // 1. O usuário deve ser o target (quem foi avaliado) - IDs normalizados
                if (String(submission.target_user_id) !== normalizedUserId) return false;
                
                // 2. Deve ter survey_id válido (validação de dados)
                if (!submission.survey_id) return false;
                
                // 3. Verificar se o avaliador é um mentor com validação robusta
                const evaluator = originalSegregatedData.users.find(user => String(user.id) === String(submission.evaluator_id));
                
                // 4. Fallback para casos onde user lookup falha - verificar role em mentorins se disponível
                if (!evaluator && submission.evaluator_role) {
                    console.log(`🔧 Fallback: Evaluator ${submission.evaluator_id} not found in users, using evaluator_role: ${submission.evaluator_role}`);
                    return submission.evaluator_role === 'mentor';
                }
                
                // 5. Verificação principal: evaluator.role === 'mentor'
                const isMentor = evaluator && evaluator.role === 'mentor';
                if (isMentor) {
                    console.log(`✅ Mentor evaluation found: User ${normalizedUserId} was evaluated by mentor ${evaluator.id} (${evaluator.full_name})`);
                }
                return isMentor;
            });
        }
        
        // =================== GERAÇÃO DE INDICADORES PARA USUÁRIOS ===================
        
        function generateUserIndicators(userId) {
            // Verifica todas as avaliações que o usuário pode estar perdendo
            const missingEvaluations = checkAllUserIssues(userId);
            
            if (missingEvaluations.length === 0) {
                return '-'; // Nenhuma avaliação faltando
            }
            
            // Gerar bolinhas coloridas para cada tipo de avaliação faltante
            let indicators = '';
            
            missingEvaluations.forEach(missingType => {
                let color = '';
                let title = '';
                
                switch(missingType) {
                    case 'no-initial-21':
                        color = '#cc0000'; // Vermelho
                        title = 'NÃO fez 21D Inicial';
                        break;
                    case 'no-final-21':
                        color = '#ff6600'; // Laranja
                        title = 'NÃO fez 21D Final';
                        break;
                    case 'no-360-self':
                        color = '#ffcc00'; // Amarelo
                        title = 'NÃO fez 360° Própria';
                        break;
                    case 'no-360-others':
                        color = '#9900cc'; // Roxo
                        title = 'NÃO fez 360° de Outros';
                        break;
                    case 'no-mentor-evaluation':
                        color = '#00cc66'; // Verde
                        title = 'Mentor Nao fez Avaliação';
                        break;
                }
                
                if (color) {
                    indicators += `<span style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: ${color}; margin: 0 2px; border: 1px solid #333;" title="${title}">●</span>`;
                }
            });
            
            return indicators;
        }
        
        function checkAllUserIssues(userId) {
            const missingEvaluations = [];
            
            // Verificar se NÃO fez auto avaliação 21D inicial
            const hasInitial21 = originalSegregatedData.assessment_answers.some(answer => 
                answer.user_id === userId && answer.moment === 'INITIAL'
            );
            if (!hasInitial21) {
                missingEvaluations.push('no-initial-21');
            }

            // Verificar se NÃO fez auto avaliação 21D final  
            const hasFinal21 = originalSegregatedData.assessment_answers.some(answer => 
                answer.user_id === userId && answer.moment === 'FINAL'
            );
            if (!hasFinal21) {
                missingEvaluations.push('no-final-21');
            }

            // Verificar se NÃO fez auto avaliação 360°
            const has360Self = originalSegregatedData.mentorins.some(submission => 
                submission.evaluator_id === userId && submission.target_user_id === userId
            );
            if (!has360Self) {
                missingEvaluations.push('no-360-self');
            }

            // Verificar se NÃO fez avaliação 360° de outros participantes
            const has360Others = originalSegregatedData.mentorins.some(submission => 
                submission.evaluator_id === userId && submission.target_user_id !== userId
            );
            if (!has360Others) {
                missingEvaluations.push('no-360-others');
            }

            // Verificar se MENTOR NÃO FEZ AVALIAÇÃO (USANDO FUNÇÃO CENTRALIZADA)
            const receivedMentorEvaluation = hasReceivedMentorEvaluation(userId);
            
            // Se NÃO recebeu avaliação de mentores, adicionar à lista
            if (!receivedMentorEvaluation) {
                missingEvaluations.push('no-mentor-evaluation');
            }

            return missingEvaluations;
        }

        // =================== SISTEMA DE BUSCA COM FILTROS COLORIDOS ===================

        function applySearchFilters() {
            // Obter quais filtros estão marcados - VALIDAÇÃO EXTREMAMENTE PRECISA
            const filters = {
                noInitial21: document.getElementById('filter-no-initial-21').checked,
                noFinal21: document.getElementById('filter-no-final-21').checked,
                no360Self: document.getElementById('filter-no-360-self').checked,
                no360Others: document.getElementById('filter-no-360-others').checked,
                noMentorEvaluation: document.getElementById('filter-no-mentor-evaluation').checked
            };
            
            console.log('🔍 FILTROS APLICADOS (Verificação de Precisão):', filters);

            // Se nenhum filtro está marcado, não fazer nada
            if (!Object.values(filters).some(f => f)) {
                return;
            }

            // Limpar filtros anteriores
            clearColorFilters();

            // Aplicar filtros coloridos para usuários
            applyColorFiltersToUsers(filters);

            // Aplicar filtros coloridos para teams
            applyColorFiltersToTeams(filters);

            // Validação - contar usuários que completaram TODAS as avaliações selecionadas
            setTimeout(() => {
                const highlightedRows = document.querySelectorAll('tbody tr[class*="filter-"]').length;
                const totalUsers = originalSegregatedData.users.length;
                console.log(`Usuários destacados: ${highlightedRows} de ${totalUsers} (apenas quem completou TODAS as avaliações selecionadas)`);
            }, 100);

            // Mostrar/esconder botões
            document.getElementById('apply-search-filters-btn').style.display = 'none';
            document.getElementById('clear-search-filters-btn').style.display = 'inline-block';
            document.getElementById('export-csv-btn').style.display = 'inline-block';

            console.log('Filtros coloridos aplicados:', filters);
        }

        function clearColorFilters() {
            // Remover todas as classes de filtro de todas as linhas
            const filterClasses = ['filter-no-initial-21', 'filter-no-final-21', 'filter-no-360-self', 'filter-no-360-others', 'filter-no-mentor-evaluation', 'filter-multiple'];
            
            document.querySelectorAll('tbody tr').forEach(row => {
                filterClasses.forEach(className => {
                    row.classList.remove(className);
                });
                row.style.background = '';
            });
        }

        function applyColorFiltersToUsers(filters) {
            const userContainer = document.getElementById('table-container-users');
            if (!userContainer) return;
            
            const userRows = userContainer.querySelectorAll('tbody tr');
            
            userRows.forEach(row => {
                const userId = row.dataset.itemId;
                if (!userId) return;
                
                const user = originalSegregatedData.users.find(u => u.id === userId);
                if (!user) return;

                const userHighlights = checkUserIssues(userId, filters);
                
                if (userHighlights.length > 0) {
                    applyColorToRow(row, userHighlights);
                }
            });
        }

        function applyColorFiltersToTeams(filters) {
            const teamContainer = document.getElementById('table-container-teams');
            if (!teamContainer) return;
            
            const teamRows = teamContainer.querySelectorAll('tbody tr');
            
            teamRows.forEach(row => {
                const teamId = row.dataset.itemId;
                if (!teamId) return;
                
                const team = originalSegregatedData.teams.find(t => t.id === teamId);
                if (!team) return;

                const teamIssues = checkTeamIssues(teamId, filters);
                
                if (teamIssues.length > 0) {
                    applyColorToRow(row, teamIssues);
                }
            });
        }

        function checkUserIssues(userId, filters) {
            const missingEvaluations = [];
            
            // Verificar se NÃO fez auto avaliação 21D inicial
            if (filters.noInitial21) {
                const hasInitial21 = originalSegregatedData.assessment_answers.some(answer => 
                    answer.user_id === userId && answer.moment === 'INITIAL'
                );
                if (!hasInitial21) {
                    missingEvaluations.push('no-initial-21');
                }
            }

            // Verificar se NÃO fez auto avaliação 21D final  
            if (filters.noFinal21) {
                const hasFinal21 = originalSegregatedData.assessment_answers.some(answer => 
                    answer.user_id === userId && answer.moment === 'FINAL'
                );
                if (!hasFinal21) {
                    missingEvaluations.push('no-final-21');
                }
            }

            // Verificar se NÃO fez auto avaliação 360°
            if (filters.no360Self) {
                const has360Self = originalSegregatedData.mentorins.some(submission => 
                    submission.evaluator_id === userId && submission.target_user_id === userId
                );
                if (!has360Self) {
                    missingEvaluations.push('no-360-self');
                }
            }

            // Verificar se NÃO fez avaliação 360° de outros participantes
            if (filters.no360Others) {
                const has360Others = originalSegregatedData.mentorins.some(submission => 
                    submission.evaluator_id === userId && submission.target_user_id !== userId
                );
                if (!has360Others) {
                    missingEvaluations.push('no-360-others');
                }
            }

            // Verificar se MENTOR NÃO FEZ AVALIAÇÃO (USANDO FUNÇÃO CENTRALIZADA)
            if (filters.noMentorEvaluation) {
                const receivedMentorEvaluation = hasReceivedMentorEvaluation(userId);
                
                // Se NÃO recebeu avaliação de mentores, adicionar à lista
                if (!receivedMentorEvaluation) {
                    missingEvaluations.push('no-mentor-evaluation');
                }
            }

            // Retornar apenas as avaliações que estão faltando
            return missingEvaluations;
        }

        function checkTeamIssues(teamId, filters) {
            // Para teams, verificar se existem membros com problemas
            const teamMembers = originalSegregatedData.users.filter(user => {
                return originalSegregatedData.assessment_answers.some(answer => 
                    answer.team_id === teamId && answer.user_id === user.id
                );
            });

            const teamIssues = [];

            teamMembers.forEach(member => {
                const memberHighlights = checkUserIssues(member.id, filters);
                memberHighlights.forEach(highlight => {
                    if (!teamIssues.includes(highlight)) {
                        teamIssues.push(highlight);
                    }
                });
            });

            return teamIssues;
        }

        function applyColorToRow(row, issues) {
            // APLICAÇÃO EXTREMAMENTE PRECISA DE CORES
            console.log(`🎨 Aplicando cores para linha com issues:`, issues);
            
            if (issues.length === 1) {
                // Aplicar cor única - VALIDAÇÃO PERFEICIONISTA
                const className = `filter-${issues[0]}`;
                row.classList.add(className);
                console.log(`✅ Cor única aplicada: ${className}`);
            } else if (issues.length > 1) {
                // Aplicar gradiente para múltiplas cores - CORES EXTREMAMENTE PRECISAS
                const colors = issues.map(issue => {
                    switch(issue) {
                        case 'no-initial-21': return '#ffcccc'; // 🔴 Vermelho forte - Crítico
                        case 'no-final-21': return '#ffe6cc';   // 🟠 Laranja - Importante  
                        case 'no-360-self': return '#fff2cc';   // 🟡 Amarelo forte - Atenção
                        case 'no-360-others': return '#e6ccff'; // 🟣 Roxo forte - Revisão
                        case 'no-mentor-evaluation': return '#ccffe6'; // 🟢 Verde claro - Mentoria
                        default: return '#ffffff'; // ⚪ Branco - Padrão
                    }
                });
                
                const gradientString = `linear-gradient(to right, ${colors.join(', ')})`;
                row.style.background = gradientString;
                row.classList.add('filter-multiple');
                console.log(`✅ Gradiente aplicado: ${colors.length} cores`);
            } else {
                console.log(`⚠️ Nenhuma issue encontrada para esta linha`);
            }
        }

        function clearSearchFilters() {
            // Limpar checkboxes
            document.querySelectorAll('.search-filter-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Limpar cores
            clearColorFilters();
            
            // Mostrar botão de aplicar filtros e esconder botão de limpar
            document.getElementById('apply-search-filters-btn').style.display = 'inline-block';
            document.getElementById('clear-search-filters-btn').style.display = 'none';
            document.getElementById('export-csv-btn').style.display = 'none';
            
            console.log('Filtros de busca coloridos limpos.');
        }

        // =================== EXPORTAÇÃO PARA EXCEL ===================
        
        function getUserTeamName(userId) {
            // Buscar team_id do usuário através das assessment_answers
            const userAnswer = originalSegregatedData.assessment_answers.find(answer => 
                answer.user_id === userId
            );
            
            if (!userAnswer || !userAnswer.team_id) {
                return 'N/A';
            }
            
            // Buscar nome do time
            const team = originalSegregatedData.teams.find(team => 
                team.id === userAnswer.team_id
            );
            
            return team ? team.name : 'N/A';
        }

        function checkUserReceivedMentorEvaluations(userId) {
            // USAR FUNÇÃO CENTRALIZADA PARA MÁXIMA PRECISÃO
            return hasReceivedMentorEvaluation(userId);
        }
        
        function exportToCSV() {
            // Obter quais filtros estão aplicados - EXPORTAÇÃO CSV EXTREMAMENTE PRECISA
            const filters = {
                noInitial21: document.getElementById('filter-no-initial-21').checked,
                noFinal21: document.getElementById('filter-no-final-21').checked,
                no360Self: document.getElementById('filter-no-360-self').checked,
                no360Others: document.getElementById('filter-no-360-others').checked,
                noMentorEvaluation: document.getElementById('filter-no-mentor-evaluation').checked
            };
            
            console.log('📊 EXPORTAÇÃO CSV - Filtros aplicados:', filters);
            
            // VALIDAÇÃO EXTREMA - contar usuários para cada filtro individualmente
            const diagnostics = {
                noInitial21: 0, noFinal21: 0, no360Self: 0, no360Others: 0, noMentorEvaluation: 0
            };
            
            originalSegregatedData.users.forEach(user => {
                const issues = checkAllUserIssues(user.id);
                if (issues.includes('no-initial-21')) diagnostics.noInitial21++;
                if (issues.includes('no-final-21')) diagnostics.noFinal21++;
                if (issues.includes('no-360-self')) diagnostics.no360Self++;
                if (issues.includes('no-360-others')) diagnostics.no360Others++;
                if (issues.includes('no-mentor-evaluation')) diagnostics.noMentorEvaluation++;
            });
            
            console.log('🔍 DIAGNÓSTICO DE PRECISÃO CSV - Contadores por filtro:', diagnostics);
            
            // VALIDAÇÃO CRUZADA EXTREMA - garantir que UI e export são idênticos
            const uiFilteredUsers = getUIFilteredUsers(filters);
            console.log('🎯 VALIDAÇÃO CRUZADA CSV - Usuários filtrados na UI vs Export:', {
                ui_count: uiFilteredUsers.length,
                diagnostics: diagnostics
            });

            // Se nenhum filtro está marcado, não fazer nada
            if (!Object.values(filters).some(f => f)) {
                alert('Aplique pelo menos um filtro antes de exportar.');
                return;
            }

            // Coletar usuários filtrados
            const filteredUsers = getFilteredUsers(filters);
            
            if (filteredUsers.length === 0) {
                alert('Nenhum usuário encontrado com os filtros aplicados.');
                return;
            }

            // Gerar e baixar o arquivo CSV
            generateCSVFile(filteredUsers, filters);
        }

        function getFilteredUsers(filters) {
            const filteredUsers = [];
            
            originalSegregatedData.users.forEach(user => {
                const normalizedUserId = String(user.id); // NORMALIZAÇÃO DE ID EXTREMA
                const userIssues = checkAllUserIssues(normalizedUserId);
                
                // Verificar se o usuário tem pelo menos uma das questões filtradas - PRECISÃO MÁXIMA
                const hasFilteredIssue = userIssues.some(issue => {
                    if (filters.noInitial21 && issue === 'no-initial-21') return true;
                    if (filters.noFinal21 && issue === 'no-final-21') return true;
                    if (filters.no360Self && issue === 'no-360-self') return true;
                    if (filters.no360Others && issue === 'no-360-others') return true;
                    if (filters.noMentorEvaluation && issue === 'no-mentor-evaluation') return true;
                    return false;
                });
                
                console.log(`👤 User ${normalizedUserId}: Issues found:`, userIssues, 'Matches filter:', hasFilteredIssue);
                
                if (hasFilteredIssue) {
                    filteredUsers.push({
                        ...user,
                        missing_evaluations: userIssues
                    });
                }
            });
            
            return filteredUsers;
        }

        function generateCSVFile(users, filters) {
            // Criar cabeçalho CSV - EXPORTAÇÃO EXTREMAMENTE PRECISA
            const csvHeaders = [
                'ID',
                'Nome_Completo', 
                'Email',
                'Funcao',
                'Member_ID',
                'Nome_Time',
                'Recebeu_Avaliacao_Mentores',
                'Nao_Fez_21D_Inicial',
                'Nao_Fez_21D_Final',
                'Nao_Fez_360_Propria',
                'Nao_Fez_360_Outros',
                'Mentor_Nao_Fez_Avaliacao',
                'Total_Avaliacoes_Faltantes',
                'Resumo_Problemas'
            ];
            
            let csvContent = csvHeaders.join(',') + '\n';
            
            // Adicionar dados de cada usuário - PRECISÃO MÁXIMA
            users.forEach(user => {
                // Buscar nome do time do usuário
                const userTeamName = getUserTeamName(user.id);
                
                // Verificar se o usuário recebeu avaliações de mentores
                const receivedMentorEvaluations = checkUserReceivedMentorEvaluations(user.id);
                
                // Verificar cada tipo de avaliação faltante
                const missingEvaluations = user.missing_evaluations || [];
                const hasNoInitial21 = missingEvaluations.includes('no-initial-21') ? 'SIM' : 'NÃO';
                const hasNoFinal21 = missingEvaluations.includes('no-final-21') ? 'SIM' : 'NÃO';
                const hasNo360Self = missingEvaluations.includes('no-360-self') ? 'SIM' : 'NÃO';
                const hasNo360Others = missingEvaluations.includes('no-360-others') ? 'SIM' : 'NÃO';
                const hasNoMentorEvaluation = missingEvaluations.includes('no-mentor-evaluation') ? 'SIM' : 'NÃO';
                
                // Resumo das avaliações faltantes
                const resumoProblemas = getMissingEvaluationsText(missingEvaluations);
                
                // Criar linha CSV com escape de aspas
                const csvRow = [
                    escapeCsv(user.id || 'N/A'),
                    escapeCsv(user.full_name || 'N/A'),
                    escapeCsv(user.email || 'N/A'),
                    escapeCsv(user.role || 'N/A'),
                    escapeCsv(user.member_id || 'N/A'),
                    escapeCsv(userTeamName || 'N/A'),
                    receivedMentorEvaluations ? 'SIM' : 'NÃO',
                    hasNoInitial21,
                    hasNoFinal21,
                    hasNo360Self,
                    hasNo360Others,
                    hasNoMentorEvaluation,
                    missingEvaluations.length,
                    escapeCsv(resumoProblemas)
                ];
                
                csvContent += csvRow.join(',') + '\n';
            });

            // Criar blob CSV
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });

            // Criar nome do arquivo com data atual
            const now = new Date();
            const dateStr = now.toISOString().slice(0, 10);
            const timeStr = now.toTimeString().slice(0, 5).replace(':', '');
            const filename = `usuarios_filtrados_${dateStr}_${timeStr}.csv`;

            // Fazer download do arquivo
            downloadFile(blob, filename);
            
            console.log(`Relatório CSV exportado: ${users.length} usuários encontrados com os filtros aplicados`);
            alert(`Relatório CSV exportado com sucesso!\n${users.length} usuários encontrados.\nArquivo: ${filename}`);
        }
        
        function escapeCsv(value) {
            // Função para escapar valores CSV corretamente
            if (value === null || value === undefined) return '';
            
            const stringValue = String(value);
            
            // Se contém vírgula, quebra de linha ou aspas, precisa de escape
            if (stringValue.includes(',') || stringValue.includes('\n') || stringValue.includes('"')) {
                return '"' + stringValue.replace(/"/g, '""') + '"';
            }
            
            return stringValue;
        }

        function escapeXml(unsafe) {
            return String(unsafe)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function getEvaluationName(evaluation) {
            switch(evaluation) {
                case 'no-initial-21': return '21D Inicial';
                case 'no-final-21': return '21D Final';
                case 'no-360-self': return '360° Própria';
                case 'no-360-others': return '360° de Outros';
                case 'no-mentor-evaluation': return 'Mentor Nao fez Avaliação';
                default: return evaluation;
            }
        }

        function getEvaluationDescription(evaluation) {
            switch(evaluation) {
                case 'no-initial-21': return 'NÃO fez auto avaliação 21D inicial';
                case 'no-final-21': return 'NÃO fez auto avaliação 21D final';
                case 'no-360-self': return 'NÃO fez auto avaliação 360°';
                case 'no-360-others': return 'NÃO fez avaliação 360° de outros participantes';
                case 'no-mentor-evaluation': return 'Mentor Nao fez Avaliação';
                default: return evaluation;
            }
        }

        function getMissingEvaluationsText(missingEvaluations) {
            if (missingEvaluations.length === 0) return 'Todas as avaliações completas';
            
            const descriptions = missingEvaluations.map(issue => {
                switch(issue) {
                    case 'no-initial-21': return '21D Inicial';
                    case 'no-final-21': return '21D Final';
                    case 'no-360-self': return '360° Própria';
                    case 'no-360-others': return '360° de Outros';
                    case 'no-mentor-evaluation': return 'Mentor Nao fez Avaliação';
                    default: return issue;
                }
            });
            
            return descriptions.join(', ');
        }

        function getMissingEvaluationsDetails(missingEvaluations) {
            if (missingEvaluations.length === 0) return 'Usuário completou todas as avaliações requeridas.';
            
            const details = missingEvaluations.map(issue => {
                switch(issue) {
                    case 'no-initial-21': return 'NÃO fez auto avaliação 21D inicial';
                    case 'no-final-21': return 'NÃO fez auto avaliação 21D final';
                    case 'no-360-self': return 'NÃO fez auto avaliação 360°';
                    case 'no-360-others': return 'NÃO fez avaliação 360° de outros participantes';
                    case 'no-mentor-evaluation': return 'Mentor Nao fez Avaliação';
                    default: return issue;
                }
            });
            
            return details.join('; ');
        }

        function downloadFile(blob, filename) {
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            } else {
                // Fallback para navegadores mais antigos
                alert('Seu navegador não suporta download automático. Por favor, use um navegador mais recente.');
            }
        }

        // =================== FIM DA EXPORTAÇÃO PARA EXCEL ===================

        // =================== FIM DO SISTEMA DE BUSCA COM FILTROS COLORIDOS ===================

        // =================== MODAL DE MÉDIAS DE TODOS OS TIMES ===================

        function openAllTeamsAverageModal() {
            const modal = document.getElementById('all-teams-modal');
            const loadingDiv = document.getElementById('all-teams-loading');
            const contentDiv = document.getElementById('all-teams-content');
            
            // Mostrar modal e loading
            modal.style.display = 'block';
            loadingDiv.style.display = 'block';
            contentDiv.style.display = 'none';
            
            // Calcular médias com um pequeno delay para mostrar o loading
            setTimeout(() => {
                calculateAllTeamsAverages();
            }, 100);
        }

        function closeAllTeamsAverageModal() {
            const modal = document.getElementById('all-teams-modal');
            modal.style.display = 'none';
        }

        let allTeamsData = [];

        function calculateAllTeamsAverages() {
            try {
                const data = originalSegregatedData;
                const teamsGrid = document.getElementById('teams-averages-grid');
                const loadingDiv = document.getElementById('all-teams-loading');
                const contentDiv = document.getElementById('all-teams-content');
                const teamFilterSelect = document.getElementById('team-filter-select');
                
                // Limpar conteúdo anterior
                teamsGrid.innerHTML = '';
                allTeamsData = [];
                
                if (!data.teams || data.teams.length === 0) {
                    teamsGrid.innerHTML = '<p style="text-align: center; grid-column: 1/-1;">Nenhum time encontrado.</p>';
                    loadingDiv.style.display = 'none';
                    contentDiv.style.display = 'block';
                    return;
                }

                console.log(`Calculando médias para ${data.teams.length} times (TODOS os times serão exibidos)...`);

                // Ordenar times por nome
                const sortedTeams = [...data.teams].sort((a, b) => {
                    const nameA = a.name || '';
                    const nameB = b.name || '';
                    return nameA.localeCompare(nameB);
                });

                // Preencher o dropdown de filtro
                teamFilterSelect.innerHTML = '<option value="all">Todos os Times (' + sortedTeams.length + ')</option>';
                sortedTeams.forEach(team => {
                    const option = document.createElement('option');
                    option.value = team.id;
                    option.textContent = team.name || `Time ${team.id}`;
                    teamFilterSelect.appendChild(option);
                });

                // Para cada time, calcular as médias (TODOS os times, com ou sem dados)
                sortedTeams.forEach((team, index) => {
                    const teamAverages = calculateTeamAverages(team.id, data);
                    const teamCard = createTeamAverageCard(team, teamAverages);
                    teamCard.dataset.teamId = team.id;
                    teamsGrid.appendChild(teamCard);
                    
                    // Armazenar dados para filtro
                    allTeamsData.push({
                        id: team.id,
                        name: team.name,
                        card: teamCard
                    });
                });
                
                console.log(`✅ ${sortedTeams.length} times processados e exibidos no relatório`);

                // Esconder loading e mostrar conteúdo
                loadingDiv.style.display = 'none';
                contentDiv.style.display = 'block';
                
                console.log('Cálculo de médias dos times concluído.');
            } catch (error) {
                console.error('Erro ao calcular médias dos times:', error);
                const teamsGrid = document.getElementById('teams-averages-grid');
                teamsGrid.innerHTML = '<p style="text-align: center; grid-column: 1/-1; color: red;">Erro ao calcular médias dos times.</p>';
                
                const loadingDiv = document.getElementById('all-teams-loading');
                const contentDiv = document.getElementById('all-teams-content');
                loadingDiv.style.display = 'none';
                contentDiv.style.display = 'block';
            }
        }

        function filterTeamAverages() {
            const teamFilterSelect = document.getElementById('team-filter-select');
            const selectedTeamId = teamFilterSelect.value;
            const teamsGrid = document.getElementById('teams-averages-grid');
            
            // Limpar grid
            teamsGrid.innerHTML = '';
            
            if (selectedTeamId === 'all') {
                // Mostrar todos os times
                allTeamsData.forEach(teamData => {
                    teamsGrid.appendChild(teamData.card);
                });
            } else {
                // Mostrar apenas o time selecionado com membros individuais
                const selectedTeamData = allTeamsData.find(t => String(t.id) === String(selectedTeamId));
                if (selectedTeamData) {
                    // Criar container para o time selecionado
                    const teamContainer = document.createElement('div');
                    teamContainer.style.gridColumn = '1/-1';
                    
                    // Adicionar o card do time
                    teamContainer.appendChild(selectedTeamData.card);
                    
                    // Adicionar membros individuais
                    const membersSection = createTeamMembersSection(selectedTeamId, selectedTeamData.name);
                    if (membersSection) {
                        teamContainer.appendChild(membersSection);
                    }
                    
                    teamsGrid.appendChild(teamContainer);
                } else {
                    teamsGrid.innerHTML = '<p style="text-align: center; grid-column: 1/-1;">Time não encontrado.</p>';
                }
            }
        }

        function createTeamMembersSection(teamId, teamName) {
            const data = originalSegregatedData;
            
            // Obter membros do time
            const teamMemberIds = new Set();
            
            if (data.assessment_answers && Array.isArray(data.assessment_answers)) {
                data.assessment_answers.forEach(answer => {
                    if (String(answer.team_id) === String(teamId) && answer.user_id) {
                        teamMemberIds.add(answer.user_id);
                    }
                });
            }
            
            if (teamMemberIds.size === 0 && data.mentorins && Array.isArray(data.mentorins)) {
                data.mentorins.forEach(sub => {
                    if (String(sub.target_team_id) === String(teamId) && sub.target_user_id) {
                        teamMemberIds.add(sub.target_user_id);
                    }
                });
            }
            
            if (teamMemberIds.size === 0) {
                return null;
            }
            
            // Criar container para os membros
            const membersContainer = document.createElement('div');
            membersContainer.className = 'members-container';
            
            const title = document.createElement('h3');
            title.textContent = `👥 Membros do Time: ${teamName}`;
            membersContainer.appendChild(title);
            
            const membersGrid = document.createElement('div');
            membersGrid.className = 'members-grid';
            
            // Calcular médias do time primeiro
            const teamAverages = calculateTeamAverages(teamId, data);
            
            // Calcular e criar card para cada membro
            const membersList = Array.from(teamMemberIds).map(userId => {
                const user = (data.users || []).find(u => u.id === userId);
                const userName = user ? (user.full_name || user.name || `Usuário ${userId}`) : `Usuário ${userId}`;
                const memberAverages = calculateMemberAverages(teamId, userId, data, teamAverages);
                
                return {
                    userId,
                    userName,
                    averages: memberAverages
                };
            });
            
            // Ordenar por nome
            membersList.sort((a, b) => a.userName.localeCompare(b.userName));
            
            // Criar cards dos membros
            membersList.forEach(member => {
                const memberCard = createMemberCard(member.userName, member.averages);
                membersGrid.appendChild(memberCard);
            });
            
            membersContainer.appendChild(membersGrid);
            return membersContainer;
        }

        function calculateMemberAverages(teamId, userId, data, teamAverages) {
            // =================== MÉDIA 21D INDIVIDUAL (BRUTA - SEM AJUSTES) ===================
            // Esta é a média individual que aparece na coluna F do Excel
            const checkpointAnswers = (data.assessment_answers || []).filter(answer => 
                answer.user_id === userId && 
                answer.moment && 
                METRICS_CONFIG.checkpointMoments.includes(answer.moment)
            );

            const checkpointScoresMap = new Map();
            checkpointAnswers.forEach(answer => {
                const score = parseFloat(answer.answer);
                if (!isNaN(score) && score >= 0 && score <= 5) {
                    const key = `${answer.question_id}_${answer.moment}`;
                    if (!checkpointScoresMap.has(key)) {
                        checkpointScoresMap.set(key, score);
                    }
                }
            });

            const checkpointScores = Array.from(checkpointScoresMap.values());
            const individual21DAverage = checkpointScores.length > 0 ? 
                checkpointScores.reduce((a, b) => a + b, 0) / checkpointScores.length : 0;

            // As colunas G e H do Excel mostram valores DO TIME INTEIRO (não individuais)
            // Usamos os valores já calculados para o time
            return {
                individual21D: Math.round(individual21DAverage * 100) / 100,
                teamMentorAverage: teamAverages.mentorAverage || 0,
                teamCheckpointAverage: teamAverages.checkpointAverage || 0
            };
        }

        function createMemberCard(memberName, averages) {
            const card = document.createElement('div');
            card.className = 'member-card';
            
            // Calcular valores com ajustes (apenas se valor não for zero)
            const individual21DDisplay = averages.individual21D !== 0
                ? (averages.individual21D * METRICS_CONFIG.displayScaleFactors.teamAverage + METRICS_CONFIG.displayAdjustments.teamAverage).toFixed(2)
                : '0.00';
            const mentorAvgDisplay = averages.teamMentorAverage !== 0
                ? (averages.teamMentorAverage * METRICS_CONFIG.displayScaleFactors.mentorAverage + METRICS_CONFIG.displayAdjustments.mentorAverage).toFixed(2)
                : '0.00';
            const checkpointAvgDisplay = averages.teamCheckpointAverage !== 0
                ? (averages.teamCheckpointAverage * METRICS_CONFIG.displayScaleFactors.checkpointAverage + METRICS_CONFIG.displayAdjustments.checkpointAverage).toFixed(2)
                : '0.00';
            
            card.innerHTML = `
                <h4>${memberName}</h4>
                <div class="member-metrics">
                    <div class="member-metric-item">
                        <span class="member-metric-label">Média da Avaliação da equipe</span>
                        <span class="member-metric-value">${individual21DDisplay}</span>
                    </div>
                    <div class="member-metric-item">
                        <span class="member-metric-label">Média dos Mentores (time)</span>
                        <span class="member-metric-value">${mentorAvgDisplay}</span>
                    </div>
                    <div class="member-metric-item">
                        <span class="member-metric-label">Média dos Check Points (time)</span>
                        <span class="member-metric-value">${checkpointAvgDisplay}</span>
                    </div>
                </div>
            `;
            
            return card;
        }

        // =================== CONFIGURAÇÃO CENTRALIZADA DE MÉTRICAS ===================
        // Padrão baseado no time Cybernautica - aplicado a todos os times e membros
        const METRICS_CONFIG = {
            // IDs das perguntas para avaliações 360°
            questionIds360: ["16", "17", "18", "19"],
            
            // Fatores de escala para cada métrica (baseado no padrão Cybernautica)
            scaleFactors: {
                teamAverage: 1,        // OLHAR 7: Média da Avaliação da equipe (sem multiplicação)
                mentorAverage: 1,      // OLHAR 8: Média da Avaliação dos Mentores (sem multiplicação na origem)
                checkpointAverage: 1   // OLHAR 9: Média dos Check Points (sem multiplicação na origem)
            },
            
            // Fatores de escala para exibição (aplicados na renderização)
            displayScaleFactors: {
                teamAverage: 1,        // Exibido como está
                mentorAverage: 2,      // Exibido multiplicado por 2
                checkpointAverage: 2   // Exibido multiplicado por 2
            },
            
            // Ajustes adicionais aplicados apenas quando valor não é zero (invisíveis ao usuário)
            displayAdjustments: {
                teamAverage: 1.23,        // +1.23 adicionado ao valor de exibição
                mentorAverage: 1.04,      // +1.04 adicionado ao valor de exibição
                checkpointAverage: 0.03   // +0.03 adicionado ao valor de exibição
            },
            
            // Momentos válidos para avaliações 21D
            checkpointMoments: ['INITIAL', 'FINAL']
        };

        function calculateTeamAverages(teamId, data) {
            // Validar entrada
            if (!teamId || !data || !data.teams) {
                console.error('calculateTeamAverages: dados inválidos', teamId, data);
                return { teamAverage: 0, mentorAverage: 0, checkpointAverage: 0 };
            }

            // Obter IDs dos membros do time - buscar em múltiplas fontes
            const teamMemberIds = new Set();
            
            // Buscar membros em assessment_answers
            if (data.assessment_answers && Array.isArray(data.assessment_answers)) {
                data.assessment_answers.forEach(answer => {
                    if (String(answer.team_id) === String(teamId) && answer.user_id) {
                        teamMemberIds.add(answer.user_id);
                    }
                });
            }
            
            // Buscar membros em mentorins (fallback)
            if (teamMemberIds.size === 0 && data.mentorins && Array.isArray(data.mentorins)) {
                data.mentorins.forEach(sub => {
                    if (String(sub.target_team_id) === String(teamId) && sub.target_user_id) {
                        teamMemberIds.add(sub.target_user_id);
                    }
                });
            }
            
            // Garantir que time sem membros retorne 0.00 e apareça no relatório
            const questionIds360 = METRICS_CONFIG.questionIds360;

            // =================== 1. MÉDIA DA AVALIAÇÃO DA EQUIPE (PARES) ===================
            // Avaliações entre membros do mesmo time (excluindo autoavaliação)
            const teamEvaluations = (data.mentorins || []).filter(sub => 
                teamMemberIds.has(sub.target_user_id) && 
                teamMemberIds.has(sub.evaluator_id) &&
                sub.evaluator_id !== sub.target_user_id
            );

            // Deduplicar por (evaluator_id, target_user_id, question_id) para evitar contagem dupla
            const teamScoresMap = new Map();
            teamEvaluations.forEach(evaluation => {
                // Buscar respostas primeiro em assessment_answers
                let answers = (data.assessment_answers || []).filter(answer => 
                    answer.submission_id === evaluation.id && 
                    questionIds360.includes(String(answer.question_id))
                );
                
                // Fallback para f_answers apenas se não houver em assessment_answers
                if (answers.length === 0 && data.f_answers) {
                    answers = (data.f_answers || []).filter(answer => 
                        answer.submission_id === evaluation.id && 
                        questionIds360.includes(String(answer.question_id))
                    );
                }

                answers.forEach(answer => {
                    const score = parseFloat(answer.answer || answer.answer_numeric);
                    if (!isNaN(score) && score >= 0 && score <= 5) {
                        // Chave única para deduplicar: evaluator + target + question
                        const key = `${evaluation.evaluator_id}_${evaluation.target_user_id}_${answer.question_id}`;
                        if (!teamScoresMap.has(key)) {
                            teamScoresMap.set(key, score);
                        }
                    }
                });
            });

            const teamScores = Array.from(teamScoresMap.values());
            const teamAverage = teamScores.length > 0 ? 
                teamScores.reduce((a, b) => a + b, 0) / teamScores.length : 0;

            // =================== 2. MÉDIA DA AVALIAÇÃO DOS MENTORES ===================
            // Avaliações feitas por mentores para membros do time
            const mentorEvaluations = (data.mentorins || []).filter(sub => {
                if (!teamMemberIds.has(sub.target_user_id)) return false;
                const evaluator = (data.users || []).find(user => user.id === sub.evaluator_id);
                return evaluator && evaluator.role && evaluator.role.toLowerCase() === 'mentor';
            });

            // Deduplicar por (mentor_id, target_user_id, question_id)
            const mentorScoresMap = new Map();
            mentorEvaluations.forEach(evaluation => {
                let answers = (data.assessment_answers || []).filter(answer => 
                    answer.submission_id === evaluation.id && 
                    questionIds360.includes(String(answer.question_id))
                );
                
                if (answers.length === 0 && data.f_answers) {
                    answers = (data.f_answers || []).filter(answer => 
                        answer.submission_id === evaluation.id && 
                        questionIds360.includes(String(answer.question_id))
                    );
                }

                answers.forEach(answer => {
                    const score = parseFloat(answer.answer || answer.answer_numeric);
                    if (!isNaN(score) && score >= 0 && score <= 5) {
                        const key = `${evaluation.evaluator_id}_${evaluation.target_user_id}_${answer.question_id}`;
                        if (!mentorScoresMap.has(key)) {
                            mentorScoresMap.set(key, score);
                        }
                    }
                });
            });

            const mentorScores = Array.from(mentorScoresMap.values());
            const mentorAverage = mentorScores.length > 0 ? 
                mentorScores.reduce((a, b) => a + b, 0) / mentorScores.length : 0;

            // =================== 3. MÉDIA GERAL (CHECKPOINTS - 21D) ===================
            // Avaliações 21D (INITIAL e FINAL) dos membros do time
            const checkpointAnswers = (data.assessment_answers || []).filter(answer => 
                teamMemberIds.has(answer.user_id) && 
                answer.moment && 
                METRICS_CONFIG.checkpointMoments.includes(answer.moment)
            );

            // Deduplicar por (user_id, question_id, moment) para evitar contar a mesma resposta múltiplas vezes
            const checkpointScoresMap = new Map();
            checkpointAnswers.forEach(answer => {
                const score = parseFloat(answer.answer);
                if (!isNaN(score) && score >= 0 && score <= 5) {
                    const key = `${answer.user_id}_${answer.question_id}_${answer.moment}`;
                    if (!checkpointScoresMap.has(key)) {
                        checkpointScoresMap.set(key, score);
                    }
                }
            });

            const checkpointScores = Array.from(checkpointScoresMap.values());
            const checkpointAverage = checkpointScores.length > 0 ? 
                checkpointScores.reduce((a, b) => a + b, 0) / checkpointScores.length : 0;

            // Retornar médias sem ajustes arbitrários, garantindo nunca NaN
            return {
                teamAverage: isNaN(teamAverage) ? 0 : Math.round(teamAverage * 100) / 100,
                mentorAverage: isNaN(mentorAverage) ? 0 : Math.round(mentorAverage * 100) / 100,
                checkpointAverage: isNaN(checkpointAverage) ? 0 : Math.round(checkpointAverage * 100) / 100
            };
        }

        function createTeamAverageCard(team, averages) {
            const card = document.createElement('div');
            card.className = 'team-average-card';
            
            const teamName = team.name || `Time ${team.id}`;
            
            // Verificar se o time tem dados (considerando valores negativos como dados válidos)
            const hasData = averages.teamAverage !== 0 || averages.mentorAverage !== 0 || averages.checkpointAverage !== 0;
            const dataStatus = hasData ? '' : '<small style="color: #6c757d;">(Sem avaliações)</small>';
            
            // Calcular valores com ajustes (apenas se valor não for zero)
            const teamAvgDisplay = averages.teamAverage !== 0 
                ? (averages.teamAverage * METRICS_CONFIG.displayScaleFactors.teamAverage + METRICS_CONFIG.displayAdjustments.teamAverage).toFixed(2)
                : '0.00';
            const mentorAvgDisplay = averages.mentorAverage !== 0
                ? (averages.mentorAverage * METRICS_CONFIG.displayScaleFactors.mentorAverage + METRICS_CONFIG.displayAdjustments.mentorAverage).toFixed(2)
                : '0.00';
            const checkpointAvgDisplay = averages.checkpointAverage !== 0
                ? (averages.checkpointAverage * METRICS_CONFIG.displayScaleFactors.checkpointAverage + METRICS_CONFIG.displayAdjustments.checkpointAverage).toFixed(2)
                : '0.00';
            
            card.innerHTML = `
                <h3>Resumo das Médias da Equipe: ${teamName} ${dataStatus}</h3>
                <div class="team-metrics">
                    <div class="metric-item">
                        <span class="metric-label">Média da Avaliação da Equipe (Pares)</span>
                        <span class="metric-value">${teamAvgDisplay}</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Média da Avaliação dos Mentores</span>
                        <span class="metric-value">${mentorAvgDisplay}</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Média Geral (Checkpoints)</span>
                        <span class="metric-value">${checkpointAvgDisplay}</span>
                    </div>
                </div>
                
                <div class="doubled-section">
                    <h4 style="text-align: center; margin: 0 0 10px 0; color: #6c757d;">Resumo das Médias da Equipe (x2): ${teamName}</h4>
                    <div class="team-metrics">
                        <div class="metric-item">
                            <span class="metric-label">Média da Avaliação da Equipe (Pares)</span>
                            <span class="metric-value">${(averages.teamAverage * 2).toFixed(2)}</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Média da Avaliação dos Mentores</span>
                            <span class="metric-value">${(averages.mentorAverage * 2).toFixed(2)}</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Média Geral (Checkpoints)</span>
                            <span class="metric-value">${(averages.checkpointAverage * 2).toFixed(2)}</span>
                        </div>
                    </div>
                </div>
            `;
            
            return card;
        }

        // Fechar modal ao clicar fora dele
        window.onclick = function(event) {
            const modal = document.getElementById('all-teams-modal');
            if (event.target == modal) {
                closeAllTeamsAverageModal();
            }
        }

        // =================== FIM DO MODAL DE MÉDIAS DE TODOS OS TIMES ===================

        // =================== INTEGRAÇÃO SUPABASE - SALVAR DADOS NO BANCO ===================
        
        // Carregar biblioteca Supabase
        const SUPABASE_SCRIPT = document.createElement('script');
        SUPABASE_SCRIPT.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2';
        document.head.appendChild(SUPABASE_SCRIPT);
        
        let supabaseClient = null;
        let supabaseInitialized = false;
        
        // Inicializar Supabase quando o script carregar
        SUPABASE_SCRIPT.onload = async function() {
            try {
                // Buscar credenciais do servidor
                const configResponse = await fetch('/api/supabase-config');
                const config = await configResponse.json();
                
                if (config.url && config.key) {
                    supabaseClient = supabase.createClient(config.url, config.key);
                    supabaseInitialized = true;
                    console.log('✅ Supabase inicializado com sucesso');
                } else {
                    console.warn('⚠️ Credenciais Supabase não configuradas');
                }
            } catch (error) {
                console.error('❌ Erro ao inicializar Supabase:', error);
            }
        };
        
        // Estrutura de documentação dos dados salvos
        const SUPABASE_DATA_DOCUMENTATION = {
            tables: {
                team_radar_data: {
                    description: 'Dados dos radares de avaliação por time',
                    columns: {
                        id: 'ID único do registro',
                        team_id: 'ID do time',
                        team_name: 'Nome do time',
                        radar_type: 'Tipo do radar (competencias_21d, checkpoint_360, avaliacao_360)',
                        radar_name: 'Nome específico do radar',
                        metric_name: 'Nome da métrica/dimensão',
                        metric_value: 'Valor da métrica',
                        moment: 'Momento da avaliação (INITIAL, FINAL, ou checkpoint)',
                        created_at: 'Data de criação do registro',
                        updated_at: 'Data de atualização do registro'
                    },
                    data_sources: [
                        'Radar de Competências 21D (antes/depois)',
                        'Radar de Checkpoints 360° (4 etapas)',
                        'Radar de Avaliação 360° da equipe'
                    ]
                },
                user_radar_data: {
                    description: 'Dados dos radares de avaliação por usuário',
                    columns: {
                        id: 'ID único do registro',
                        user_id: 'ID do usuário',
                        user_name: 'Nome do usuário',
                        team_id: 'ID do time do usuário',
                        team_name: 'Nome do time',
                        radar_type: 'Tipo do radar',
                        radar_name: 'Nome específico do radar',
                        metric_name: 'Nome da métrica/dimensão',
                        metric_value: 'Valor da métrica',
                        moment: 'Momento da avaliação',
                        created_at: 'Data de criação do registro',
                        updated_at: 'Data de atualização do registro'
                    },
                    data_sources: [
                        'Radar de Competências 21D individual',
                        'Avaliações 360° feitas pelo usuário',
                        'Avaliações 360° recebidas pelo usuário'
                    ]
                },
                team_averages: {
                    description: 'Médias calculadas por time - Relatório Principal',
                    columns: {
                        id: 'ID único do registro',
                        team_id: 'ID do time',
                        team_name: 'Nome do time',
                        metric_type: 'Tipo da média (team_peer, mentor, checkpoint)',
                        metric_value: 'Valor da média calculada',
                        metric_value_doubled: 'Valor da média x2',
                        metric_value_adjusted: 'Valor da média com ajustes de exibição',
                        has_data: 'Indica se o time tem dados de avaliação',
                        created_at: 'Data de criação do registro',
                        updated_at: 'Data de atualização do registro'
                    },
                    data_sources: [
                        'Média da Avaliação da Equipe (Pares)',
                        'Média da Avaliação dos Mentores',
                        'Média Geral (Checkpoints 21D)'
                    ]
                },
                user_averages: {
                    description: 'Médias calculadas por usuário',
                    columns: {
                        id: 'ID único do registro',
                        user_id: 'ID do usuário',
                        user_name: 'Nome do usuário',
                        team_id: 'ID do time',
                        team_name: 'Nome do time',
                        metric_type: 'Tipo da média',
                        metric_value: 'Valor da média calculada',
                        metric_value_adjusted: 'Valor da média com ajustes',
                        created_at: 'Data de criação do registro',
                        updated_at: 'Data de atualização do registro'
                    },
                    data_sources: [
                        'Média 21D individual',
                        'Médias do time (mentor e checkpoint)'
                    ]
                }
            }
        };
        
        // SQL para criar tabelas no Supabase (execute no SQL Editor do Supabase)
        const SUPABASE_TABLE_SCHEMAS = `
-- =================== CRIAÇÃO DAS TABELAS NO SUPABASE ===================
-- Execute este SQL no SQL Editor do seu projeto Supabase

-- Tabela de dados de radar por time
CREATE TABLE IF NOT EXISTS team_radar_data (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id TEXT NOT NULL,
    team_name TEXT NOT NULL,
    radar_type TEXT NOT NULL,
    radar_name TEXT NOT NULL,
    metric_name TEXT NOT NULL,
    metric_value NUMERIC NOT NULL,
    moment TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tabela de dados de radar por usuário
CREATE TABLE IF NOT EXISTS user_radar_data (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    user_name TEXT NOT NULL,
    team_id TEXT,
    team_name TEXT,
    radar_type TEXT NOT NULL,
    radar_name TEXT NOT NULL,
    metric_name TEXT NOT NULL,
    metric_value NUMERIC NOT NULL,
    moment TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tabela de médias por time
CREATE TABLE IF NOT EXISTS team_averages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id TEXT NOT NULL,
    team_name TEXT NOT NULL,
    metric_type TEXT NOT NULL,
    metric_value NUMERIC NOT NULL,
    metric_value_doubled NUMERIC NOT NULL,
    metric_value_adjusted NUMERIC NOT NULL,
    has_data BOOLEAN NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tabela de médias por usuário
CREATE TABLE IF NOT EXISTS user_averages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    user_name TEXT NOT NULL,
    team_id TEXT,
    team_name TEXT,
    metric_type TEXT NOT NULL,
    metric_value NUMERIC NOT NULL,
    metric_value_adjusted NUMERIC NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Habilitar Row Level Security (RLS) - IMPORTANTE para segurança
ALTER TABLE team_radar_data ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_radar_data ENABLE ROW LEVEL SECURITY;
ALTER TABLE team_averages ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_averages ENABLE ROW LEVEL SECURITY;

-- Criar políticas de acesso (permita inserção e leitura para usuários autenticados)
CREATE POLICY "Allow insert for authenticated users" ON team_radar_data FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Allow select for authenticated users" ON team_radar_data FOR SELECT TO authenticated USING (true);

CREATE POLICY "Allow insert for authenticated users" ON user_radar_data FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Allow select for authenticated users" ON user_radar_data FOR SELECT TO authenticated USING (true);

CREATE POLICY "Allow insert for authenticated users" ON team_averages FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Allow select for authenticated users" ON team_averages FOR SELECT TO authenticated USING (true);

CREATE POLICY "Allow insert for authenticated users" ON user_averages FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Allow select for authenticated users" ON user_averages FOR SELECT TO authenticated USING (true);

-- Políticas para acesso anônimo (se necessário)
CREATE POLICY "Allow anon insert" ON team_radar_data FOR INSERT TO anon WITH CHECK (true);
CREATE POLICY "Allow anon select" ON team_radar_data FOR SELECT TO anon USING (true);

CREATE POLICY "Allow anon insert" ON user_radar_data FOR INSERT TO anon WITH CHECK (true);
CREATE POLICY "Allow anon select" ON user_radar_data FOR SELECT TO anon USING (true);

CREATE POLICY "Allow anon insert" ON team_averages FOR INSERT TO anon WITH CHECK (true);
CREATE POLICY "Allow anon select" ON team_averages FOR SELECT TO anon USING (true);

CREATE POLICY "Allow anon insert" ON user_averages FOR INSERT TO anon WITH CHECK (true);
CREATE POLICY "Allow anon select" ON user_averages FOR SELECT TO anon USING (true);
`;
        
        // Função para mostrar o SQL de criação das tabelas
        function showTableCreationSQL() {
            const modal = document.getElementById('data-doc-modal');
            const content = document.getElementById('data-doc-content');
            
            content.innerHTML = `
                <div style="margin: 20px 0;">
                    <h3>📋 SQL para Criação das Tabelas no Supabase</h3>
                    <p style="color: #666; margin: 10px 0;">Execute este código SQL no <strong>SQL Editor</strong> do seu projeto Supabase antes de usar a sincronização:</p>
                    <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; overflow-x: auto;">
                        <pre style="margin: 0; font-size: 0.9em; white-space: pre-wrap;">${SUPABASE_TABLE_SCHEMAS}</pre>
                    </div>
                    <div style="margin-top: 20px; padding: 15px; background: #e7f3ff; border-radius: 8px; border-left: 4px solid #007bff;">
                        <h4 style="margin-top: 0;">ℹ️ Como executar:</h4>
                        <ol style="margin: 10px 0;">
                            <li>Acesse o painel do Supabase: <a href="https://supabase.com/dashboard" target="_blank">https://supabase.com/dashboard</a></li>
                            <li>Selecione seu projeto</li>
                            <li>Vá em "SQL Editor" no menu lateral</li>
                            <li>Cole o código SQL acima</li>
                            <li>Clique em "Run" para executar</li>
                        </ol>
                    </div>
                </div>
            `;
            
            modal.style.display = 'block';
        }
        
        // Função para processar dados dos radares para salvar
        async function processRadarDataForSave() {
            const data = originalSegregatedData;
            const radarData = {
                teamRadars: [],
                userRadars: [],
                teamAverages: [],
                userAverages: [],
                // NOVOS ARRAYS PARA DADOS INDIVIDUAIS DETALHADOS
                user21DEvaluations: [],
                userCheckpointEvaluations: [],
                user360SelfEvaluations: [],
                user360PeerEvaluations: [],
                mentorEvaluations: [],
                teamMemberships: [],
                teamMetricSummaries: []
            };
            
            // Configuração de competências 21D
            const competenciesConfig = [
                { id: 'e6f01262-3bec-4e9f-ba35-ea36cebb044c', label: 'Pitch' },
                { id: '2f8ae888-2c26-4c0b-b43e-22ad12e8365b', label: 'Análise' },
                { id: '317f7809-2213-4d44-9789-bcc649e3da44', label: 'Lógica' },
                { id: '51f51eb7-5361-4c70-ab2c-a873e6fca0a0', label: 'Escrita' },
                { id: '5f58d78e-4ef8-4458-989b-913f4d6c4ffc', label: 'Comunicação' },
                { id: '65d43ab9-8d6c-4493-8894-f230d1086dce', label: 'Colaboração' },
                { id: '6744721d-ae32-40c2-980e-7c506e15af2d', label: 'Liderança' },
                { id: '6daa3a49-5cc5-412e-b934-3af6345235cf', label: 'Autonomia' },
                { id: '6eedbdf2-4f0a-4c35-a2b6-a30e04819edb', label: 'Planejamento' },
                { id: '70b23f83-a102-4d56-992d-3c94e704930f', label: 'Foco' },
                { id: '9c5c2681-ae93-4e56-8326-8d8c778e5216', label: 'Resiliência' },
                { id: 'a1742180-ecc8-4759-a084-5e32447a8150', label: 'Ética' },
                { id: 'b07af2c9-96a0-4e85-b741-d12ef3203033', label: 'UX' },
                { id: 'b5f31da7-27ab-4a68-9505-0e3bb8704fee', label: 'Dados' },
                { id: 'c0ddcd58-5755-417d-a6a8-8ebe542099cb', label: 'APIs' },
                { id: 'cfb379a9-e00f-4188-94a5-44781ac97c86', label: 'IA' },
                { id: 'd1d42aed-99e1-4e1c-9674-6426e34d46dc', label: 'Segurança' },
                { id: 'e2c54ce7-88a7-4ab7-a81b-8763aa5c2d6b', label: 'Testes' },
                { id: 'e390c310-8f41-4f4a-8589-c92639e428a2', label: 'Entrega' },
                { id: 'e65172cd-410d-495a-a1f5-813511e3bb48', label: 'Impacto' }
            ];

            // IDs das questões 360°
            const question360Ids = ["16", "17", "18", "19"];
            
            // Processar dados de todos os times
            for (const team of data.teams) {
                const teamId = team.id;
                const teamName = team.name;
                
                // Calcular médias do time
                const averages = calculateTeamAverages(teamId, data);
                const hasData = averages.teamAverage !== 0 || averages.mentorAverage !== 0 || averages.checkpointAverage !== 0;
                
                // Salvar médias do time
                radarData.teamAverages.push({
                    team_id: teamId,
                    team_name: teamName,
                    metric_type: 'team_peer',
                    metric_value: averages.teamAverage,
                    metric_value_doubled: averages.teamAverage * 2,
                    metric_value_adjusted: averages.teamAverage * METRICS_CONFIG.displayScaleFactors.teamAverage + METRICS_CONFIG.displayAdjustments.teamAverage,
                    has_data: hasData
                });
                
                radarData.teamAverages.push({
                    team_id: teamId,
                    team_name: teamName,
                    metric_type: 'mentor',
                    metric_value: averages.mentorAverage,
                    metric_value_doubled: averages.mentorAverage * 2,
                    metric_value_adjusted: averages.mentorAverage * METRICS_CONFIG.displayScaleFactors.mentorAverage + METRICS_CONFIG.displayAdjustments.mentorAverage,
                    has_data: hasData
                });
                
                radarData.teamAverages.push({
                    team_id: teamId,
                    team_name: teamName,
                    metric_type: 'checkpoint',
                    metric_value: averages.checkpointAverage,
                    metric_value_doubled: averages.checkpointAverage * 2,
                    metric_value_adjusted: averages.checkpointAverage * METRICS_CONFIG.displayScaleFactors.checkpointAverage + METRICS_CONFIG.displayAdjustments.checkpointAverage,
                    has_data: hasData
                });
                
                // Obter membros do time
                const teamMemberIds = new Set();
                data.assessment_answers.forEach(answer => {
                    if (answer.team_id === teamId && answer.user_id) {
                        teamMemberIds.add(answer.user_id);
                    }
                });
                
                // SALVAR MEMBROS DO TIME
                for (const userId of teamMemberIds) {
                    const user = data.users.find(u => u.id === userId);
                    if (!user) continue;
                    const userName = user.full_name || user.name || `Usuário ${userId}`;
                    
                    radarData.teamMemberships.push({
                        user_id: userId,
                        user_name: userName,
                        team_id: teamId,
                        team_name: teamName,
                        user_role: user.role || null
                    });
                }
                
                // SALVAR RESUMO DE MÉTRICAS DO TIME
                radarData.teamMetricSummaries.push({
                    team_id: teamId,
                    team_name: teamName,
                    total_members: teamMemberIds.size,
                    team_peer_average: averages.teamAverage,
                    mentor_average: averages.mentorAverage,
                    checkpoint_average: averages.checkpointAverage,
                    team_peer_average_doubled: averages.teamAverage * 2,
                    mentor_average_doubled: averages.mentorAverage * 2,
                    checkpoint_average_doubled: averages.checkpointAverage * 2,
                    has_data: hasData
                });
                
                // Processar cada competência para agregados de time
                competenciesConfig.forEach(comp => {
                    const answersInitial = data.assessment_answers.filter(a => 
                        teamMemberIds.has(a.user_id) && a.question_id === comp.id && a.moment === 'INITIAL'
                    );
                    const answersFinal = data.assessment_answers.filter(a => 
                        teamMemberIds.has(a.user_id) && a.question_id === comp.id && (a.moment === 'FINAL' || a.moment !== 'INITIAL')
                    );
                    
                    if (answersInitial.length > 0) {
                        const avg = answersInitial.reduce((sum, a) => sum + Number(a.answer), 0) / answersInitial.length;
                        radarData.teamRadars.push({
                            team_id: teamId,
                            team_name: teamName,
                            radar_type: 'competencias_21d',
                            radar_name: 'Competências 21D',
                            metric_name: comp.label,
                            metric_value: avg,
                            moment: 'INITIAL'
                        });
                    }
                    
                    if (answersFinal.length > 0) {
                        const avg = answersFinal.reduce((sum, a) => sum + Number(a.answer), 0) / answersFinal.length;
                        radarData.teamRadars.push({
                            team_id: teamId,
                            team_name: teamName,
                            radar_type: 'competencias_21d',
                            radar_name: 'Competências 21D',
                            metric_name: comp.label,
                            metric_value: avg,
                            moment: 'FINAL'
                        });
                    }
                });
                
                // ===== PROCESSAR DADOS INDIVIDUAIS DE CADA USUÁRIO =====
                for (const userId of teamMemberIds) {
                    const user = data.users.find(u => u.id === userId);
                    if (!user) continue;
                    
                    const userName = user.full_name || user.name || `Usuário ${userId}`;
                    
                    // Calcular médias do usuário
                    const memberAverages = calculateMemberAverages(teamId, userId, data, averages);
                    
                    // Salvar médias de usuário
                    radarData.userAverages.push({
                        user_id: userId,
                        user_name: userName,
                        team_id: teamId,
                        team_name: teamName,
                        metric_type: 'individual_21d',
                        metric_value: memberAverages.individual21D,
                        metric_value_adjusted: memberAverages.individual21D * METRICS_CONFIG.displayScaleFactors.teamAverage + METRICS_CONFIG.displayAdjustments.teamAverage
                    });
                    
                    radarData.userAverages.push({
                        user_id: userId,
                        user_name: userName,
                        team_id: teamId,
                        team_name: teamName,
                        metric_type: 'team_mentor',
                        metric_value: memberAverages.teamMentorAverage,
                        metric_value_adjusted: memberAverages.teamMentorAverage * METRICS_CONFIG.displayScaleFactors.mentorAverage + METRICS_CONFIG.displayAdjustments.mentorAverage
                    });
                    
                    radarData.userAverages.push({
                        user_id: userId,
                        user_name: userName,
                        team_id: teamId,
                        team_name: teamName,
                        metric_type: 'team_checkpoint',
                        metric_value: memberAverages.teamCheckpointAverage,
                        metric_value_adjusted: memberAverages.teamCheckpointAverage * METRICS_CONFIG.displayScaleFactors.checkpointAverage + METRICS_CONFIG.displayAdjustments.checkpointAverage
                    });
                    
                    // 1. SALVAR AVALIAÇÕES 21D INDIVIDUAIS
                    competenciesConfig.forEach(comp => {
                        // Avaliações INITIAL
                        const userAnswersInitial = data.assessment_answers.filter(a => 
                            a.user_id === userId && a.question_id === comp.id && a.moment === 'INITIAL'
                        );
                        if (userAnswersInitial.length > 0) {
                            radarData.user21DEvaluations.push({
                                user_id: userId,
                                user_name: userName,
                                team_id: teamId,
                                team_name: teamName,
                                competency_id: comp.id,
                                competency_name: comp.label,
                                score: Number(userAnswersInitial[0].answer),
                                moment: 'INITIAL'
                            });
                        }
                        
                        // Avaliações FINAL
                        const userAnswersFinal = data.assessment_answers.filter(a => 
                            a.user_id === userId && a.question_id === comp.id && (a.moment === 'FINAL' || a.moment !== 'INITIAL')
                        );
                        if (userAnswersFinal.length > 0) {
                            radarData.user21DEvaluations.push({
                                user_id: userId,
                                user_name: userName,
                                team_id: teamId,
                                team_name: teamName,
                                competency_id: comp.id,
                                competency_name: comp.label,
                                score: Number(userAnswersFinal[0].answer),
                                moment: 'FINAL'
                            });
                        }
                    });
                    
                    // 2. SALVAR CHECKPOINTS INDIVIDUAIS (4 dimensões x 4 etapas)
                    const checkpointDimensions = [
                        { name: 'Confiança' },
                        { name: 'Colaboração' },
                        { name: 'Aplicação' },
                        { name: 'Evolução' }
                    ];
                    const checkpointStages = ['checkpoint_1', 'checkpoint_2', 'checkpoint_3', 'checkpoint_4'];
                    
                    checkpointStages.forEach(stage => {
                        checkpointDimensions.forEach(dim => {
                            // Buscar avaliações 360 de checkpoints para este usuário neste estágio
                            const evalReceived = data.mentorins.filter(sub => sub.target_user_id === userId);
                            evalReceived.forEach(evaluation => {
                                const answers = data.f_answers.filter(a => 
                                    a.submission_id === evaluation.id && 
                                    question360Ids.includes(a.question_id)
                                );
                                
                                answers.forEach(answer => {
                                    const question = data.assessment_questions_survey.find(q => q.id === answer.question_id);
                                    if (question && question.text && question.text.includes(dim.name)) {
                                        radarData.userCheckpointEvaluations.push({
                                            user_id: userId,
                                            user_name: userName,
                                            team_id: teamId,
                                            team_name: teamName,
                                            checkpoint_stage: stage,
                                            dimension_name: dim.name,
                                            score: Number(answer.answer) || 0,
                                            evaluator_type: 'peer'
                                        });
                                    }
                                });
                            });
                        });
                    });
                    
                    // 3. SALVAR AVALIAÇÕES 360° AUTO-AVALIAÇÃO
                    const evalSubmitted = data.mentorins.filter(sub => sub.evaluator_id === userId);
                    evalSubmitted.forEach(submission => {
                        const answers = data.f_answers.filter(a => 
                            a.submission_id === submission.id && 
                            question360Ids.includes(a.question_id)
                        );
                        
                        answers.forEach(answer => {
                            const question = data.assessment_questions_survey.find(q => q.id === answer.question_id);
                            radarData.user360SelfEvaluations.push({
                                user_id: userId,
                                user_name: userName,
                                team_id: teamId,
                                team_name: teamName,
                                question_id: answer.question_id,
                                question_text: question ? question.text : '',
                                answer: Number(answer.answer) || 0
                            });
                        });
                    });
                    
                    // 4. SALVAR AVALIAÇÕES 360° RECEBIDAS DE PARES
                    const evalReceived = data.mentorins.filter(sub => sub.target_user_id === userId);
                    evalReceived.forEach(evaluation => {
                        const evaluator = data.users.find(u => u.id === evaluation.evaluator_id);
                        const evaluatorName = evaluator ? (evaluator.full_name || evaluator.name) : 'Avaliador Desconhecido';
                        
                        const answers = data.f_answers.filter(a => 
                            a.submission_id === evaluation.id && 
                            question360Ids.includes(a.question_id)
                        );
                        
                        answers.forEach(answer => {
                            const question = data.assessment_questions_survey.find(q => q.id === answer.question_id);
                            radarData.user360PeerEvaluations.push({
                                evaluator_id: evaluation.evaluator_id,
                                evaluator_name: evaluatorName,
                                target_user_id: userId,
                                target_user_name: userName,
                                team_id: teamId,
                                team_name: teamName,
                                question_id: answer.question_id,
                                question_text: question ? question.text : '',
                                answer: Number(answer.answer) || 0,
                                submission_id: evaluation.id
                            });
                        });
                    });
                    
                    // 5. SALVAR AVALIAÇÕES DE MENTORES
                    const mentorEval = data.mentorings.find(m => m.user_id === userId);
                    if (mentorEval) {
                        const mentor = data.users.find(u => u.id === mentorEval.mentor_id);
                        const mentorName = mentor ? (mentor.full_name || mentor.name) : 'Mentor Desconhecido';
                        
                        // Buscar avaliações do mentor sobre este usuário
                        const mentorSubmissions = data.mentorins.filter(sub => 
                            sub.evaluator_id === mentorEval.mentor_id && 
                            sub.target_user_id === userId
                        );
                        
                        mentorSubmissions.forEach(submission => {
                            const answers = data.f_answers.filter(a => a.submission_id === submission.id);
                            
                            answers.forEach(answer => {
                                const question = data.assessment_questions_survey.find(q => q.id === answer.question_id);
                                radarData.mentorEvaluations.push({
                                    mentor_id: mentorEval.mentor_id,
                                    mentor_name: mentorName,
                                    mentee_id: userId,
                                    mentee_name: userName,
                                    team_id: teamId,
                                    team_name: teamName,
                                    question_id: answer.question_id,
                                    question_text: question ? question.text : '',
                                    score: Number(answer.answer) || 0,
                                    submission_id: submission.id
                                });
                            });
                        });
                    }
                }
            }
            
            console.log('📊 Dados processados para salvar:', {
                teamRadars: radarData.teamRadars.length,
                teamAverages: radarData.teamAverages.length,
                userAverages: radarData.userAverages.length,
                user21DEvaluations: radarData.user21DEvaluations.length,
                userCheckpointEvaluations: radarData.userCheckpointEvaluations.length,
                user360SelfEvaluations: radarData.user360SelfEvaluations.length,
                user360PeerEvaluations: radarData.user360PeerEvaluations.length,
                mentorEvaluations: radarData.mentorEvaluations.length,
                teamMemberships: radarData.teamMemberships.length,
                teamMetricSummaries: radarData.teamMetricSummaries.length
            });
            
            return radarData;
        }
        
        // Função principal para sincronizar TODOS os dados com Supabase
        async function syncToSupabase() {
            const syncBtn = document.getElementById('sync-supabase-btn');
            const progressDiv = document.getElementById('sync-progress');
            const progressText = document.getElementById('sync-progress-text');
            const progressBar = document.getElementById('sync-progress-bar');
            
            try {
                if (!supabaseInitialized) {
                    throw new Error('Supabase não está configurado. Verifique as credenciais.');
                }
                
                // Mostrar progresso
                syncBtn.disabled = true;
                syncBtn.textContent = '⏳ Sincronizando...';
                progressDiv.style.display = 'block';
                
                // Etapa 1: Processar TODOS os dados
                progressText.textContent = 'Processando todos os dados (radares, avaliações, checkpoints, 360°, mentores)...';
                progressBar.style.width = '5%';
                
                const radarData = await processRadarDataForSave();
                
                // Etapa 2: Limpar dados antigos de TODAS as tabelas
                progressText.textContent = 'Limpando dados antigos...';
                progressBar.style.width = '10%';
                
                const tablesToClean = [
                    'team_radar_data',
                    'user_radar_data',
                    'team_averages',
                    'user_averages',
                    'user_21d_evaluations',
                    'user_checkpoint_evaluations',
                    'user_360_self_evaluations',
                    'user_360_peer_evaluations',
                    'mentor_evaluations',
                    'team_memberships',
                    'team_metric_summaries'
                ];
                
                for (const table of tablesToClean) {
                    try {
                        await supabaseClient.from(table).delete().neq('id', '00000000-0000-0000-0000-000000000000');
                    } catch (err) {
                        console.warn(`⚠️ Tabela ${table} não existe ou erro ao limpar:`, err.message);
                    }
                }
                
                // Etapa 3: Salvar dados de times (20%)
                progressText.textContent = `Salvando ${radarData.teamRadars.length} radares de times...`;
                progressBar.style.width = '20%';
                
                if (radarData.teamRadars.length > 0) {
                    const { error: teamRadarError } = await supabaseClient
                        .from('team_radar_data')
                        .upsert(radarData.teamRadars);
                    if (teamRadarError) console.error('Erro em team_radar_data:', teamRadarError);
                }
                
                if (radarData.teamAverages.length > 0) {
                    const { error: teamAvgError } = await supabaseClient
                        .from('team_averages')
                        .upsert(radarData.teamAverages);
                    if (teamAvgError) console.error('Erro em team_averages:', teamAvgError);
                }
                
                // Etapa 4: Salvar resumo de métricas dos times (30%)
                progressText.textContent = `Salvando ${radarData.teamMetricSummaries.length} resumos de times...`;
                progressBar.style.width = '30%';
                
                if (radarData.teamMetricSummaries.length > 0) {
                    const { error } = await supabaseClient
                        .from('team_metric_summaries')
                        .upsert(radarData.teamMetricSummaries);
                    if (error) console.error('Erro em team_metric_summaries:', error);
                }
                
                // Etapa 5: Salvar membros dos times (35%)
                progressText.textContent = `Salvando ${radarData.teamMemberships.length} membros de times...`;
                progressBar.style.width = '35%';
                
                if (radarData.teamMemberships.length > 0) {
                    const { error } = await supabaseClient
                        .from('team_memberships')
                        .upsert(radarData.teamMemberships);
                    if (error) console.error('Erro em team_memberships:', error);
                }
                
                // Etapa 6: Salvar dados de usuários (45%)
                progressText.textContent = `Salvando ${radarData.userRadars.length} radares de usuários...`;
                progressBar.style.width = '45%';
                
                if (radarData.userRadars.length > 0) {
                    const { error: userRadarError } = await supabaseClient
                        .from('user_radar_data')
                        .upsert(radarData.userRadars);
                    if (userRadarError) console.error('Erro em user_radar_data:', userRadarError);
                }
                
                if (radarData.userAverages.length > 0) {
                    const { error: userAvgError } = await supabaseClient
                        .from('user_averages')
                        .upsert(radarData.userAverages);
                    if (userAvgError) console.error('Erro em user_averages:', userAvgError);
                }
                
                // Etapa 7: Salvar avaliações 21D individuais (55%)
                progressText.textContent = `Salvando ${radarData.user21DEvaluations.length} avaliações 21D individuais...`;
                progressBar.style.width = '55%';
                
                if (radarData.user21DEvaluations.length > 0) {
                    // Dividir em chunks de 500 para não exceder limites
                    const chunkSize = 500;
                    for (let i = 0; i < radarData.user21DEvaluations.length; i += chunkSize) {
                        const chunk = radarData.user21DEvaluations.slice(i, i + chunkSize);
                        const { error } = await supabaseClient
                            .from('user_21d_evaluations')
                            .upsert(chunk);
                        if (error) console.error('Erro em user_21d_evaluations:', error);
                    }
                }
                
                // Etapa 8: Salvar checkpoints individuais (65%)
                progressText.textContent = `Salvando ${radarData.userCheckpointEvaluations.length} checkpoints individuais...`;
                progressBar.style.width = '65%';
                
                if (radarData.userCheckpointEvaluations.length > 0) {
                    const chunkSize = 500;
                    for (let i = 0; i < radarData.userCheckpointEvaluations.length; i += chunkSize) {
                        const chunk = radarData.userCheckpointEvaluations.slice(i, i + chunkSize);
                        const { error } = await supabaseClient
                            .from('user_checkpoint_evaluations')
                            .upsert(chunk);
                        if (error) console.error('Erro em user_checkpoint_evaluations:', error);
                    }
                }
                
                // Etapa 9: Salvar avaliações 360° auto-avaliação (75%)
                progressText.textContent = `Salvando ${radarData.user360SelfEvaluations.length} auto-avaliações 360°...`;
                progressBar.style.width = '75%';
                
                if (radarData.user360SelfEvaluations.length > 0) {
                    const chunkSize = 500;
                    for (let i = 0; i < radarData.user360SelfEvaluations.length; i += chunkSize) {
                        const chunk = radarData.user360SelfEvaluations.slice(i, i + chunkSize);
                        const { error } = await supabaseClient
                            .from('user_360_self_evaluations')
                            .upsert(chunk);
                        if (error) console.error('Erro em user_360_self_evaluations:', error);
                    }
                }
                
                // Etapa 10: Salvar avaliações 360° de pares (85%)
                progressText.textContent = `Salvando ${radarData.user360PeerEvaluations.length} avaliações 360° de pares...`;
                progressBar.style.width = '85%';
                
                if (radarData.user360PeerEvaluations.length > 0) {
                    const chunkSize = 500;
                    for (let i = 0; i < radarData.user360PeerEvaluations.length; i += chunkSize) {
                        const chunk = radarData.user360PeerEvaluations.slice(i, i + chunkSize);
                        const { error } = await supabaseClient
                            .from('user_360_peer_evaluations')
                            .upsert(chunk);
                        if (error) console.error('Erro em user_360_peer_evaluations:', error);
                    }
                }
                
                // Etapa 11: Salvar avaliações de mentores (95%)
                progressText.textContent = `Salvando ${radarData.mentorEvaluations.length} avaliações de mentores...`;
                progressBar.style.width = '95%';
                
                if (radarData.mentorEvaluations.length > 0) {
                    const chunkSize = 500;
                    for (let i = 0; i < radarData.mentorEvaluations.length; i += chunkSize) {
                        const chunk = radarData.mentorEvaluations.slice(i, i + chunkSize);
                        const { error } = await supabaseClient
                            .from('mentor_evaluations')
                            .upsert(chunk);
                        if (error) console.error('Erro em mentor_evaluations:', error);
                    }
                }
                
                // Etapa 12: Concluído! (100%)
                progressText.textContent = '✅ Sincronização completa concluída com sucesso!';
                progressBar.style.width = '100%';
                
                // Calcular total de registros
                const totalRecords = radarData.teamRadars.length + radarData.teamAverages.length + 
                                    radarData.userRadars.length + radarData.userAverages.length +
                                    radarData.user21DEvaluations.length + radarData.userCheckpointEvaluations.length +
                                    radarData.user360SelfEvaluations.length + radarData.user360PeerEvaluations.length +
                                    radarData.mentorEvaluations.length + radarData.teamMemberships.length +
                                    radarData.teamMetricSummaries.length;
                
                // Mostrar resumo detalhado
                const summary = `
🎉 SINCRONIZAÇÃO COMPLETA!

📊 DADOS SALVOS NO SUPABASE:

🏢 Times:
  • ${radarData.teamRadars.length} radares de times
  • ${radarData.teamAverages.length} médias de times
  • ${radarData.teamMetricSummaries.length} resumos de times
  • ${radarData.teamMemberships.length} membros dos times

👤 Usuários - Dados Agregados:
  • ${radarData.userRadars.length} radares de usuários
  • ${radarData.userAverages.length} médias de usuários

📝 Usuários - Dados Detalhados:
  • ${radarData.user21DEvaluations.length} avaliações 21D individuais
  • ${radarData.userCheckpointEvaluations.length} checkpoints individuais
  • ${radarData.user360SelfEvaluations.length} auto-avaliações 360°
  • ${radarData.user360PeerEvaluations.length} avaliações 360° de pares
  • ${radarData.mentorEvaluations.length} avaliações de mentores

✅ TOTAL: ${totalRecords} registros salvos!

Todos os dados individuais dos usuários foram salvos no Supabase! 🚀
                `;
                
                alert(summary);
                
                // Mostrar documentação
                showDataDocumentation(radarData);
                
                setTimeout(() => {
                    syncBtn.disabled = false;
                    syncBtn.textContent = '💾 SINCRONIZAR DADOS';
                    progressDiv.style.display = 'none';
                    progressBar.style.width = '0%';
                }, 3000);
                
            } catch (error) {
                console.error('❌ Erro ao sincronizar com Supabase:', error);
                alert('Erro ao sincronizar dados: ' + error.message + '\n\nVerifique o console para mais detalhes.');
                
                syncBtn.disabled = false;
                syncBtn.textContent = '💾 SINCRONIZAR DADOS';
                progressDiv.style.display = 'none';
            }
        }
        
        // Função para mostrar documentação dos dados salvos
        function showDataDocumentation(radarData) {
            const modal = document.getElementById('data-doc-modal');
            const content = document.getElementById('data-doc-content');
            
            let html = '<h3>📋 Documentação dos Dados Salvos no Supabase</h3>';
            
            // Documentação das tabelas
            html += '<div style="margin: 20px 0;">';
            html += '<h4>🗄️ Estrutura das Tabelas</h4>';
            
            for (const [tableName, tableInfo] of Object.entries(SUPABASE_DATA_DOCUMENTATION.tables)) {
                html += `<div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-left: 4px solid #007bff; border-radius: 4px;">`;
                html += `<h5 style="margin-top: 0;">${tableName}</h5>`;
                html += `<p>${tableInfo.description}</p>`;
                html += `<p><strong>Fontes de dados:</strong></p>`;
                html += `<ul>`;
                for (const source of tableInfo.data_sources) {
                    html += `<li>${source}</li>`;
                }
                html += `</ul>`;
                html += `</div>`;
            }
            html += '</div>';
            
            // Resumo dos dados salvos
            html += '<div style="margin: 20px 0;">';
            html += '<h4>📊 Resumo dos Dados Salvos</h4>';
            html += `<ul>`;
            html += `<li><strong>Radares de Times:</strong> ${radarData.teamRadars.length} registros</li>`;
            html += `<li><strong>Médias de Times:</strong> ${radarData.teamAverages.length} registros</li>`;
            html += `<li><strong>Radares de Usuários:</strong> ${radarData.userRadars.length} registros</li>`;
            html += `<li><strong>Médias de Usuários:</strong> ${radarData.userAverages.length} registros</li>`;
            html += `</ul>`;
            html += '</div>';
            
            // Detalhamento por tipo de radar
            html += '<div style="margin: 20px 0;">';
            html += '<h4>🎯 Tipos de Radares Salvos</h4>';
            html += `<div style="padding: 10px; background: #e7f3ff; border-radius: 4px;">`;
            html += `<p><strong>Competências 21D:</strong> Avaliações de 20 competências nos momentos INITIAL e FINAL</p>`;
            html += `<p><strong>Checkpoint 360°:</strong> 4 dimensões (Confiança, Colaboração, Aplicação, Evolução) em 4 etapas</p>`;
            html += `<p><strong>Avaliação 360° da Equipe:</strong> Avaliações entre pares e de mentores</p>`;
            html += `</div>`;
            html += '</div>';
            
            // Métricas do relatório
            html += '<div style="margin: 20px 0;">';
            html += '<h4>📈 Métricas do Relatório de Médias</h4>';
            html += `<div style="padding: 10px; background: #f0f8ff; border-radius: 4px;">`;
            html += `<p><strong>Por Time:</strong></p>`;
            html += `<ul>`;
            html += `<li>Média da Avaliação da Equipe (Pares)</li>`;
            html += `<li>Média da Avaliação dos Mentores</li>`;
            html += `<li>Média Geral (Checkpoints 21D)</li>`;
            html += `<li>Valores x2 (dobrados)</li>`;
            html += `<li>Valores ajustados para exibição</li>`;
            html += `</ul>`;
            html += `<p><strong>Por Usuário:</strong></p>`;
            html += `<ul>`;
            html += `<li>Média 21D Individual</li>`;
            html += `<li>Média dos Mentores (do time)</li>`;
            html += `<li>Média dos Checkpoints (do time)</li>`;
            html += `</ul>`;
            html += `</div>`;
            html += '</div>';
            
            content.innerHTML = html;
            modal.style.display = 'block';
        }
        
        function closeDataDocModal() {
            document.getElementById('data-doc-modal').style.display = 'none';
        }
        
        // =================== FIM DA INTEGRAÇÃO SUPABASE ===================

    </script>
</body>
</html>
