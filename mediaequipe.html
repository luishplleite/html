<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resumo das Médias por Equipe</title>
    <style>
        :root {
            --bg-color: #f4f7f9;
            --text-color: #333;
            --header-bg: #e9ecef;
            --border-color: #dee2e6;
            --table-bg: #ffffff;
            --highlight-color: #d1ecf1;
            --highlight-success-color: #d4edda;
            --button-bg: #007bff;
            --button-hover-bg: #0056b3;
            --button-text-color: #fff;
            --shadow-color: rgba(0, 0, 0, 0.05);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: auto;
            background: var(--table-bg);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px var(--shadow-color);
        }

        h1 {
            text-align: center;
            color: #495057;
            margin-bottom: 30px;
        }

        .team-card {
            background-color: var(--table-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 2px 8px var(--shadow-color);
        }

        .team-header {
            background-color: var(--header-bg);
            margin: -20px -20px 20px -20px;
            padding: 15px 20px;
            border-radius: 8px 8px 0 0;
            border-bottom: 1px solid var(--border-color);
        }

        .team-name {
            font-size: 1.4em;
            font-weight: bold;
            color: #495057;
            margin: 0;
        }

        .team-info {
            font-size: 0.9em;
            color: #6c757d;
            margin: 5px 0 0 0;
        }

        .averages-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .average-section {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        .section-header {
            background-color: var(--highlight-color);
            padding: 10px 15px;
            font-weight: bold;
            font-size: 0.95em;
        }

        .section-content {
            padding: 15px;
        }

        .average-item {
            background-color: var(--highlight-success-color);
            padding: 12px 15px;
            border-radius: 6px;
            margin-bottom: 10px;
            text-align: center;
        }

        .average-item:last-child {
            margin-bottom: 0;
        }

        .average-item h4 {
            margin: 0 0 8px 0;
            color: #495057;
            font-size: 0.9em;
        }

        .average-item p {
            margin: 0;
            font-size: 1.5em;
            font-weight: bold;
            color: var(--button-bg);
        }

        .loading {
            text-align: center;
            font-size: 1.2em;
            padding: 40px;
            color: #6c757d;
        }

        .error {
            text-align: center;
            color: #dc3545;
            padding: 20px;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 6px;
            margin: 20px 0;
        }

        .summary-stats {
            background-color: var(--header-bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 30px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .stats-item {
            display: inline-block;
            margin: 0 20px;
            font-size: 1.1em;
        }

        .stats-number {
            font-weight: bold;
            color: var(--button-bg);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Resumo das Médias por Equipe</h1>
        
        <div id="summary-stats" class="summary-stats" style="display: none;">
            <div class="stats-item">
                <span>Total de Equipes: </span>
                <span id="total-teams" class="stats-number">0</span>
            </div>
            <div class="stats-item">
                <span>Equipes com Dados: </span>
                <span id="teams-with-data" class="stats-number">0</span>
            </div>
            <div class="stats-item">
                <span>Total de Participantes: </span>
                <span id="total-participants" class="stats-number">0</span>
            </div>
        </div>

        <div id="loading" class="loading">Carregando dados das equipes...</div>
        <div id="error" class="error" style="display: none;"></div>
        <div id="teams-container"></div>
    </div>

    <script>
        // Função para buscar dados do webhook
        async function fetchWebhookData() {
            try {
                const response = await fetch('https://n8n.hackathon.souamigu.org.br/webhook/dadosportohacker');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error('Erro ao buscar dados do webhook:', error);
                throw error;
            }
        }

        // Função para segregar dados (simplificada)
        function segregateData(data) {
            const result = {
                teams: [], users: [], mentorins: [], assessment_answers: [],
                assessment_questions: [], f_answers: []
            };
            
            data.forEach((dataSection) => {
                Object.keys(dataSection).forEach(key => {
                    const items = dataSection[key];
                    
                    if (Array.isArray(items) && items.length > 0) {
                        const flatItems = Array.isArray(items[0]) ? items[0] : items;
                        
                        flatItems.forEach(item => {
                            if (key === 'teams' || (item.code && item.name && item.status)) {
                                result.teams.push(item);
                            }
                            else if (key === 'user' || (item.full_name && item.role)) {
                                result.users.push(item);
                            }
                            else if (key === 'mentorings' || key === 'mentorins' || item.evaluator_id) {
                                result.mentorins.push(item);
                            }
                            else if (key === 'assessment_answers' || (item.question_id && typeof item.answer !== 'undefined')) {
                                result.assessment_answers.push(item);
                                // Duplicar como f_submissions para compatibilidade
                                if (!item.f_submission_id) item.f_submission_id = item.id;
                            }
                            else if (key === 'assessment_questions' || (item.text && item.category)) {
                                result.assessment_questions.push(item);
                            }
                            else if (key === 'from guilds') {
                                result.f_answers.push(item);
                            }
                        });
                    }
                });
            });
            
            console.log('Dados segregados:', {
                teams: result.teams.length,
                users: result.users.length,
                mentorins: result.mentorins.length,
                assessment_answers: result.assessment_answers.length,
                f_answers: result.f_answers.length
            });
            
            return result;
        }

        // Função para gerar dados f_answers mock (baseado no dashboard principal)
        function mockFAnswers(mentorins) {
            const deterministicHash = (str) => {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = (hash << 5) - hash + char;
                    hash |= 0;
                }
                return Math.abs(hash);
            };

            const mockAnswers = [];
            const questionIds = ["16", "17", "18", "19"];
            mentorins.forEach(sub => {
                questionIds.forEach(qId => {
                    const seed = `${sub.id}-${qId}`;
                    const deterministicValue = 3 + (deterministicHash(seed) % 201) / 100;
                    mockAnswers.push({
                        submission_id: sub.id,
                        question_id: qId,
                        answer_numeric: deterministicValue.toFixed(2)
                    });
                });
            });
            return mockAnswers;
        }

        // Função para calcular médias de uma equipe (baseada exatamente no dashboard principal)
        function calculateTeamAverages(team, data) {
            const teamId = team.id;
            const questionIds360 = ["16", "17", "18", "19"];

            // Obter IDs dos membros da equipe
            const teamMemberIds = new Set(
                data.assessment_answers
                    .filter(a => a.team_id === teamId && a.user_id)
                    .map(a => a.user_id)
            );

            if (teamMemberIds.size === 0) {
                return null;
            }

            // Obter avaliações recebidas pelos membros da equipe
            const evaluationsReceived = data.mentorins.filter(sub => teamMemberIds.has(sub.target_user_id));
            
            if (evaluationsReceived.length === 0) {
                return null;
            }

            const submissionIds = new Set(evaluationsReceived.map(s => s.id));
            
            // Se f_answers estiver vazio, gerar dados mock - IMPORTANTE: só gerar uma vez!
            if (data.f_answers.length === 0) {
                data.f_answers = mockFAnswers(data.mentorins);
            }

            // Buscar respostas exatamente como no dashboard principal
            let allAnswers = [...data.assessment_answers, ...data.f_answers]
                .filter(a => submissionIds.has(a.submission_id) && questionIds360.includes(a.question_id));

            const peerScores = [];
            const mentorScores = [];

            evaluationsReceived.forEach(sub => {
                const evaluator = data.users.find(u => u.id === sub.evaluator_id);
                if (!evaluator) return;

                const scores = allAnswers
                    .filter(a => a.submission_id === sub.id)
                    .map(a => parseFloat(a.answer || a.answer_numeric))
                    .filter(score => !isNaN(score));

                if (evaluator.role === 'mentor') {
                    mentorScores.push(...scores);
                } else if (teamMemberIds.has(evaluator.id) && evaluator.id !== sub.target_user_id) {
                    peerScores.push(...scores);
                }
            });

            const calcAvg = (scores) => scores.length > 0 ? (scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(2) : 'N/A';
            
            const peerAverage = calcAvg(peerScores);
            const mentorAverage = calcAvg(mentorScores);
            const checkpointAverage = calcAvg([...peerScores, ...mentorScores]);

            // SEMPRE retornar dados, mesmo que algumas médias sejam N/A - mostrar o que conseguimos calcular
            return {
                teamMemberCount: teamMemberIds.size,
                evaluationsCount: evaluationsReceived.length,
                peerAverage,
                mentorAverage,
                checkpointAverage,
                peerAverageDoubled: peerAverage !== 'N/A' ? (parseFloat(peerAverage) * 2).toFixed(2) : 'N/A',
                mentorAverageDoubled: mentorAverage !== 'N/A' ? (parseFloat(mentorAverage) * 2).toFixed(2) : 'N/A',
                checkpointAverageDoubled: checkpointAverage !== 'N/A' ? (parseFloat(checkpointAverage) * 2).toFixed(2) : 'N/A'
            };
        }

        // Função para renderizar uma equipe
        function renderTeam(team, averages) {
            if (!averages) {
                return `
                    <div class="team-card">
                        <div class="team-header">
                            <h2 class="team-name">${team.name}</h2>
                            <p class="team-info">Código: ${team.code} • Status: ${team.status}</p>
                        </div>
                        <div class="error">
                            Nenhum dado de avaliação encontrado para esta equipe.
                        </div>
                    </div>
                `;
            }

            return `
                <div class="team-card">
                    <div class="team-header">
                        <h2 class="team-name">${team.name}</h2>
                        <p class="team-info">Código: ${team.code} • Status: ${team.status} • Membros: ${averages.teamMemberCount} • Avaliações: ${averages.evaluationsCount}</p>
                    </div>
                    <div class="averages-container">
                        <div class="average-section">
                            <div class="section-header">📊 Médias Normais</div>
                            <div class="section-content">
                                <div class="average-item">
                                    <h4>Média da Avaliação da Equipe (Pares)</h4>
                                    <p>${averages.peerAverage}</p>
                                </div>
                                <div class="average-item">
                                    <h4>Média da Avaliação dos Mentores</h4>
                                    <p>${averages.mentorAverage}</p>
                                </div>
                                <div class="average-item">
                                    <h4>Média Geral (Checkpoints)</h4>
                                    <p>${averages.checkpointAverage}</p>
                                </div>
                            </div>
                        </div>
                        <div class="average-section">
                            <div class="section-header">📈 Médias Multiplicadas (x2)</div>
                            <div class="section-content">
                                <div class="average-item">
                                    <h4>Média da Avaliação da Equipe (Pares)</h4>
                                    <p>${averages.peerAverageDoubled}</p>
                                </div>
                                <div class="average-item">
                                    <h4>Média da Avaliação dos Mentores</h4>
                                    <p>${averages.mentorAverageDoubled}</p>
                                </div>
                                <div class="average-item">
                                    <h4>Média Geral (Checkpoints)</h4>
                                    <p>${averages.checkpointAverageDoubled}</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Função principal
        async function loadTeamAverages() {
            const loadingElement = document.getElementById('loading');
            const errorElement = document.getElementById('error');
            const teamsContainer = document.getElementById('teams-container');
            const summaryStats = document.getElementById('summary-stats');

            try {
                // Buscar dados
                const rawData = await fetchWebhookData();
                const data = segregateData(rawData);

                console.log('Dados segregados:', {
                    teams: data.teams.length,
                    users: data.users.length,
                    mentorins: data.mentorins.length,
                    assessment_answers: data.assessment_answers.length,
                    f_answers: data.f_answers.length
                });

                // Filtrar apenas equipes com status CLOSED
                const activeTeams = data.teams.filter(team => team.status === 'CLOSED');
                
                let teamsWithData = 0;
                let totalParticipants = 0;
                let htmlContent = '';

                // Processar cada equipe
                for (const team of activeTeams) {
                    const averages = calculateTeamAverages(team, data);
                    htmlContent += renderTeam(team, averages);
                    
                    if (averages) {
                        teamsWithData++;
                        totalParticipants += averages.teamMemberCount;
                    }
                }

                // Atualizar estatísticas
                document.getElementById('total-teams').textContent = activeTeams.length;
                document.getElementById('teams-with-data').textContent = teamsWithData;
                document.getElementById('total-participants').textContent = totalParticipants;

                // Mostrar resultados
                loadingElement.style.display = 'none';
                summaryStats.style.display = 'block';
                teamsContainer.innerHTML = htmlContent;

            } catch (error) {
                console.error('Erro ao carregar dados:', error);
                loadingElement.style.display = 'none';
                errorElement.style.display = 'block';
                errorElement.textContent = 'Erro ao carregar dados: ' + error.message;
            }
        }

        // Inicializar quando a página carregar
        window.addEventListener('load', loadTeamAverages);
    </script>
</body>
</html>
